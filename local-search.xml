<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[Paper Notes] Napa: Powering Scalable Data Warehousing with Robust Query Performance at Google</title>
    <link href="/napa/"/>
    <url>/napa/</url>
    
    <content type="html"><![CDATA[<p>Materialized View 成了最近数据库的新热潮，大数据三驾马车的原厂 Google 也发了一篇 PVLDB，介绍他们替代 Mesa 的新系统 Napa。<a href="http://vldb.org/pvldb/vol14/p2986-sankaranarayanan.pdf">Paper 链接</a>。随便分享一些 notes 和 unresolved issues（比较乱，不能作为 Paper 的替代品）</p><a id="more"></a><p>首先 brief 一下 Napa 这篇 paper 有比较有意思的点：</p><ol><li>精细的成本管理，把 trade off 的权利交给用户的同时避免了很繁琐的细节配置。</li><li>引入了类似 Watermark 的一个新概念 QT (Queryable Timestamp) 的来向用户描述 freshness（但跟 watermark 有区别）。</li></ol><h2 id="Napa-的核心概念"><a href="#Napa-的核心概念" class="headerlink" title="Napa 的核心概念"></a>Napa 的核心概念</h2><p>Napa 是 Google 用来替代 <a href="https://research.google/pubs/pub42851/">Mesa</a> 的新一代数仓，向 Google 的广告客户以及内部用于分析。一个最重要的变更是引入了 Materialized view 的概念来加速查询。有几个重要的指标是 Napa 关心的：</p><ol><li>Ingestion throughput：导入数据的速度是至关重要的</li><li>Query performance：查询请求的性能（延迟）</li><li>Data freshness：查询到的数据是否更新？一分钟内的数据还是几小时内的数据都行？</li><li>Resource Cost：每导入一定量数据需要的各种资源。</li></ol><p>当然除此之外，Durability 和 Fault tolerance 肯定是必要的。</p><p>Ingestion throughput 是不可放弃的选择（数据都导不进去谈什么查询），剩下的都可以交给客户端来 trade off。</p><h3 id="LSMT"><a href="#LSMT" class="headerlink" title="LSMT"></a>LSMT</h3><p>Napa 中直接导入数据的表称为 base table，而每个 base table 会有若干关联的 materialized view（n to m 的关系，每个 materialized view 也可能不止关联一个 table）。每个 Materialized view 的结构类似一颗 LSM Tree，一条外部数据从其他系统导入到 Napa 需要经过一系列过程：</p><ol><li>Ingestion<br> 对应到 LSM Tree 里应该就是 write memtable + WAL 的过程，不过这里不需要写 memtable，这个类似 WAL 的结构叫做 non-queryable delta，由于更新是 apply 到 base table 上的，所以这个数据只需要写一份 base table，就可以认为 ingestion 成功了，保证了 durability。Ingestion 的过程也会在多个机房同步。</li><li>Compation and view maintainance: Napa 的 Compaction 混合了好几个概念，我们一个个抽出来：<ul><li>Non-queryable delta -&gt; View Queryable delta<br>  根据我们上面的描述，Non-queryable delta 只是 base table 的 WAL，那么我们首先需要把这个 log 中的每一项更新读出来，并根据每个 Materialized view 定义的算子进行转换，确定是否要 apply 到对应的 view 中。同时我们也会做一些排序、索引的工作，最后生成的是 n 个 queryable delta（对应于 LSM 中 SST 的概念），n 为需要更新的 view 的数量。</li><li>Queryable delta merge: 与 LSM 的 merge 完全相同，定期将一部分 Queryable delta 合并为一个更大的 Queryable delta。</li></ul></li></ol><p>而对一个 view 进行一次 query 的过程跟 LSM 也完全相同，即并行地在若干个 delta 进行查询，并将结果合并。</p><p>而几个关键的指标基本都受到这套体系的影响：</p><ol><li>Ingestion throughput：如同 LSM Tree 一样，ingestion 成功即导入成功，高度写优化，导入飞快。</li><li>Query performance，取决于两个要素：<ul><li>view 的数量，view 的查询性能会比 base table 更好</li><li>查询的时候需要对多少个 delta file 查询，越多性能越差</li></ul></li><li>Data freshness：Non-queryable 的数据是完全不可读的，因此查询的结果至少会延迟到 non-queryable delta 的合并。除此之外，我们还可以自己选择仅读取一部分的 queryable delta，这样会牺牲 freshness，但是能提高 query performance。</li><li>Resource costs：Base Table 的更新是必要的，因此可以认为完全是 view 的维护成本，取决于 view 的数量和 compaction 的频率。</li></ol><h3 id="Queryable-Timestamp"><a href="#Queryable-Timestamp" class="headerlink" title="Queryable Timestamp"></a>Queryable Timestamp</h3><p><img src="https://user-images.githubusercontent.com/9161438/129359740-0114a772-9dca-4b06-9480-869001f4dda8.png" alt="QT"></p><p>QT 是一个表示 freshness 的概念，Now() - QT 代表了 frsehness 的 bound。QT 有一个上限，就是不能超过 Non-queryable delta 里的下界（因为 Non-queryable delta 完全不可查询），QT 是受到用户配置影响的。查询时会合并到 QT 为止所有的 delta（而不是全部的 delta）。</p><h3 id="tradeoff-query-performance"><a href="#tradeoff-query-performance" class="headerlink" title="tradeoff query performance"></a>tradeoff query performance</h3><p>要 data freshness，但 query 可以慢点儿</p><ol><li>少建 view，慢慢查</li><li>少做 view maintainance task（delta file 会特别多）</li><li>QT 设置得足够高（查询时会合并所有的 delta file 中的结果）</li></ol><h3 id="tradeoff-data-freshness"><a href="#tradeoff-data-freshness" class="headerlink" title="tradeoff data freshness"></a>tradeoff data freshness</h3><p>需要 query performance，但是读到的数据可以旧点儿</p><ol><li>少做 view maintainance（delta file 会特别多）</li><li>QT 设置得足够低（查询时需要合并的 delta file 特别少）</li></ol><h3 id="tradeoff-resource-costs"><a href="#tradeoff-resource-costs" class="headerlink" title="tradeoff resource costs"></a>tradeoff resource costs</h3><p>既要 query performance，又要 data freshness。</p><p><img src="https://user-images.githubusercontent.com/9161438/129360955-e3701121-8e26-45da-a970-90e40930ae2e.png" alt="我全都要"></p><p>没有什么是充钱解决不了的。</p><ol><li>多建 view。</li><li>频繁做 view maintainance。</li><li>QT 设置得足够高</li></ol><p><img src="https://user-images.githubusercontent.com/9161438/129365009-5c3e40a3-6a95-45ff-b4ad-aaec7355038d.png" alt="tradeoff"></p><h2 id="外部系统"><a href="#外部系统" class="headerlink" title="外部系统"></a>外部系统</h2><p><img src="https://user-images.githubusercontent.com/9161438/129364456-ace178bc-ea96-4250-bf4f-ad88a8c299b3.png" alt="Architecture"></p><p>Google 的 infra 是真的强，所以我感觉其实 Napa 做的最重要的事情就是上面这个 LSMT 了，其他的都通过外部系统解决。Napa 使用了 Colossus（下一代 GFS）做文件存储，并且用 F1 query 做了物化视图的 Planner 和 Optimizer（我觉得是工程量最大的一部分），以及面向客户端的 query servering。Napa 自身更多负责视图的维护。</p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p><strong>物化视图的自动淘汰</strong></p><p>文中提了很多 challenges，但其中我感觉比较关键的一点，物化视图的及时淘汰。对用户来说，QT 是个 database 级别的概念，如果有一个物化视图的更新比较慢（也许是视图太复杂，或者 plan 优化不够），那么 Now() - QT 就会越来越大，freshness 无法保证，需要及时淘汰掉这些 view（读到这里的时候我才发现原来 view 可能不是用户指定创建的，居然还是可以自动加减的。。就离谱）。</p><p><strong>为什么 QT 不是 Watermark？</strong></p><p>回收一个开头的疑问，因为 Napa 并不是一个 streaming system，它的输入是 Ordering 的（或者说完全基于 Process time 而非 Event time）。Watermark 描述的是 query 的 completeness（即 query time &lt; watermark 代表一定能读到完整的结果），而 QT 描述的是 freshness（即 query time &lt; QT 可以获得符合预期的性能）。</p><p><strong>Napa 提供了怎么样的一致性？</strong></p><p>从我个人的 taste 来看，一个让人用得舒服的数据库，无论是 TP 还是 AP，提供 atomic batch update 和 global snapshot read （即使是 stale snapshot）是必要的选择。这篇 paper 关于一致性的描述非常少，不过两点观察：</p><ol><li>Mesa 内置了 MVCC，提供了 strong consistency，Napa 作为 Mesa 的 drop-in replacement 不提供的话我感觉用户不会买帐？</li><li>LSMT 的架构下做 MVCC 是非常简单的事情。</li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>总体来说感觉还是比较中规中矩的一些 idea，不过也可以看出 Google 对工程细节的把控非常深了。比如同样是 LSMT 的架构，我怀疑换成 TiDB 的话，robust query performance 可能更取决于查询线程池的调度、gRPC 各种不确定因素而非 delta file 的数量。只有在工程细节上优化得足够好，才能在各个指标上更加可控的 trade off configuration。</p><p>数据库服务需要很强的确定性，相比于 auto driven 来说，这种 trade off configuration 说不定对用户是个更好的选择。（然后我准备去看另一篇 PVLDB auto driven 了）</p><p><del>彩蛋：<a href="blog.zhuangty.com">blog.zhuangty.com</a> 终于用上 Google analytics 了，说不定 tygg 在看报表的时候也用上 napa 了</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>Database</tag>
      
      <tag>Paper Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用可持久化 B+ 树优化 OFFSET 子句</title>
    <link href="/optimize-offset-with-persistent-bptree/"/>
    <url>/optimize-offset-with-persistent-bptree/</url>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/9161438/126614791-22d7a7cc-cf5f-4384-8b87-6ff91b7c0047.png" alt="某网站的分页"></p><p>分页功能是网站常见的需求之一，对应到数据库中的实现，通常会用 <code>LIMIT ? OFFSET ?</code> 的子句来实现，然而这是很多网站被攻击的潜在原因之一。在主流的数据库实现中，这种查询的效率往往非常的低下。本文脑洞了一种高效支持 OFFSET LIMIT 的方法。</p><a id="more"></a><p>首先让我们看看到底有多慢。以 MySQL 为例：</p><p>首先我们在 mysql 中创建一张简单的表，并用 sysbench 导入 10M 条数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sysbench --mysql-host=127.0.0.1 --mysql-db=<span class="hljs-built_in">test</span> --mysql-user=root oltp_point_select prepare --table-size=10000000<br></code></pre></td></tr></table></figure><p>这并不是很大的一个数据量，然后我们执行一条简单查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test.sbtest1 limit <span class="hljs-number">10</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">9000000</span>;<br><br><span class="hljs-number">10</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span><br><span class="hljs-type">Time</span>: <span class="hljs-number">7.993</span>s<br></code></pre></td></tr></table></figure><p>这样一个简单的查询需要花费 8 秒左右的时间，而且当我用 sysbench 去压这条 SQL 的时候它直接挂了。在具体的实现，OFFSET LIMIT 这种操作基本都是通过扫描来实现的，很难跳过前序的行数，而 OFFSET 越大意味着需要扫描的数据越多。一个正常的用户通常只会刷前几页的数据，但是被 hack 的时候就很难说了，也许只需要把 url 里的 pageNo=1 改成 pageNo=10000 并且高并发请求一下，一些网站就挂了，当然现在这种场景已经很少了。</p><p>很难跳过不代表无法跳过，我们从 MySQL 底层的索引数据结构 B+ 树说起。</p><p><img src="https://user-images.githubusercontent.com/9161438/128887249-df068b4a-bfb2-480a-a12b-95d613103938.png" alt="B+ 树"></p><p>上图是一个简单的两层4阶 B+ 树，由一个非叶节点和四个叶节点组成，叶节点之间通过链表连接，用于提高 scan 性能。</p><p>我们想做一个分页查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">4</span> LIMIT <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>对应到存储结构上，就是希望找到这个索引树上第四个到第五个元素 <code>btree.range(4, 6)</code>，20 和 24。目前的实现里，我们显然只能左到右扫描，在无意义地访问了连个不需要的节点后，我们才能找到正确的节点和对应的数据。很显然，如果我们在每个非叶节点上实时维护所有子树的 count 的话，我们就能更快地找到结果。</p><p><img src="https://user-images.githubusercontent.com/9161438/128887368-1cc052a0-6114-433a-bc9d-7a26e57eaa02.png" alt="带计数的 B+ 树"></p><p>通过非叶节点上的 count 记录，我们就可以先通过 root 节点的 count，确认第四条纪录从第三个叶节点开始，然后直接找到数据并开始扫描，总体时间是 $log(n)$ 的复杂度。当然，这会导致我们每次插入或者删除数据的时候也需要更新一整条树路径上的所有非叶节点。</p><p><strong>MVCC</strong></p><p>在支持事务的数据库里，往往使用 MVCC 来减少读写之间的锁冲突。MVCC 在叶节点中的数据，存的是一串链表（O2N），代表了数据的更新记录，而 seq 代表了。支持了 MVCC 后，我们很快发现我们的 count-B+ tree 不好使了。</p><p>我们分别进行了一次插入，一次修改和一次删除，这也就导致了我们查询不同 version 的时候，正确的结果是不一样的。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-number">18</span>, <span class="hljs-string">&quot;j1&quot;</span>, version=<span class="hljs-number">3</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-number">16</span>, <span class="hljs-string">&quot;d2&quot;</span>, version=<span class="hljs-number">5</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-number">20</span>, version=<span class="hljs-number">7</span>)</span></span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">4</span> LIMIT <span class="hljs-number">2</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> version <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-operator">|</span>key<span class="hljs-operator">|</span><span class="hljs-keyword">value</span><span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">20</span> <span class="hljs-operator">|</span>e1   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">24</span> <span class="hljs-operator">|</span>f1   <span class="hljs-operator">|</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">4</span> LIMIT <span class="hljs-number">2</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> version <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br><span class="hljs-operator">|</span>key<span class="hljs-operator">|</span><span class="hljs-keyword">value</span><span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">18</span> <span class="hljs-operator">|</span>j1   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">20</span> <span class="hljs-operator">|</span>e1   <span class="hljs-operator">|</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">4</span> LIMIT <span class="hljs-number">2</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> version <span class="hljs-operator">=</span> <span class="hljs-number">8</span><br><span class="hljs-operator">|</span>key<span class="hljs-operator">|</span><span class="hljs-keyword">value</span><span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">18</span> <span class="hljs-operator">|</span>j1   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">20</span> <span class="hljs-operator">|</span>e1   <span class="hljs-operator">|</span><br></code></pre></td></tr></table></figure><p>我们的计数只能支持对最新数据的查询，而在修改发生之前已经创建好的 ReadView，我们就无能为力了。</p><p><strong>多版本计数</strong></p><p>既然数据可以做多版本，那么我们的计数理所当然也可以。</p><p><img src="https://user-images.githubusercontent.com/9161438/128887776-fc7bbbb5-0aef-4fce-b83c-6b56f343be83.png" alt="带多版本计数的 B+ 树"></p><p>在多版本计数上，我们“如愿以偿”地查到了我们想要的结果。</p><p><strong>B+ 树的分裂</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-number">37</span>, <span class="hljs-string">&quot;k1&quot;</span>, version=<span class="hljs-number">9</span>)</span></span><br></code></pre></td></tr></table></figure><p>上面的思路依然是死路一条，我们考虑 B+ 树的分裂和合并，多版本计数是完全不可维护的。</p><p><img src="https://user-images.githubusercontent.com/9161438/128887786-c17dba97-c356-431f-8305-cee179b0aa2d.png" alt="多版本计数B+树的分裂"></p><p><strong>可持久化数据结构</strong></p><p>我们先直接看一下我们用可持久化 B+ 树优化后的结果，为了简化做图，我们假设我们仅做了两次插入：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-number">18</span>, <span class="hljs-string">&quot;j1&quot;</span>, version=<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-number">37</span>, <span class="hljs-string">&quot;k1&quot;</span>, version=<span class="hljs-number">3</span>)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/9161438/128887963-4e63911d-7fd2-4eb9-8aac-3a727a30ac79.png" alt="可持久化B+树"></p><p>可以看到，相比于原来的 B+ 树，我们引入了两个变化：</p><ol><li>不再就地修改数据。</li><li>删除了叶节点之间的指针（这删了还能叫 B+ 树吗？-_-）</li></ol><p>在第一次进行插入后，我们直接 copy 了一份根节点和第二个叶节点，并插入数据，新的节点（黄色）另外三个指针依然指向原来的叶节点，只有第二个指针指向了新的节点。</p><p>而第二次插入直接引发了分裂，因此我们一共创建了五个新节点， 包括：</p><ol><li>原先的第四个节点分裂后的新的叶节点（30，37 开头）</li><li>原先的 root 节点分裂后的两个非叶节点上（10、30 开头的绿色节点）</li><li>新的 root 节点</li></ol><p>可以看到一波操作之后，我们拥有了三个版本的 B+ 树！每个版本都是一个符合我们预期的全局快照，我们查找的时候可以先快速找到需要的版本，然后在每个版本上快速地进行符合我们优化预期分页查询。与此同时，我们也并没有占用三倍的空间，理论的空间复杂度是 $n+m log(n)$ 其中 n 是树的大小，m 是维护的版本数。</p><p><a href="https://en.wikipedia.org/wiki/Persistent_data_structure">可持久化数据结构</a> 是一个数据结构上的概念，但跟 MVCC 不谋而合。而当我们尝试在数据库上使用了可持久化B+树后，我们事实上是把 MVCC 做到了整个索引的数据结构里，而非行记录里。整个索引结构从 <code>BPTree&lt;Key, PersistentList&lt;Value&gt;&gt;</code> 转变为了 <code>List&lt;PersistentBPTree&lt;Key, Value&gt;&gt;</code>。</p><p>另一个问题是，为什么我把叶节点之间的连接指针删掉了，因为不删没法做，原因可以留给读者思考一下，这也是可持久化数据结构的局限性之一。</p><p><strong>Mixing mode</strong></p><p>考虑到这种实现的 clone 代价还是太高，也许可以混合三种方式做这个优化：</p><ol><li>UPDATE 时，只添加行记录，做行级 MVCC。</li><li>INSERT/DELETE 但不涉及树的结构变更时，使用多版本计数（可以记在内存里，反正可以恢复出来）。</li><li>发生树结构的变更时，直接创建一个新版本的 B+ 树。</li></ol><p>查询时：</p><ol><li>先通过全局的版本链表找到一个 B+ 树。</li><li>通过 B+ 树非叶节点上的多版本计数，快速定位到行记录。</li><li>通过行记录上的多版本 MVCC，定位到需要读取的数据。</li></ol><p>（实现上想想就很恶心，所以连图都不想画了）</p><p><strong>后记</strong></p><p><del>后来还写了个 Rust 的实现，但写得不太好不想开源了，反正可持久化数据结构无脑 Arc 就对了</del></p><p>分页其实是个很小众的需求，在数据库支持不佳的情况下，业务上也有了很多替换解决方案，完全没有必要花很大代价去做优化，所以这篇文章还是搞笑为主的（不搞笑我肯定发 paper 了谁写 blog 啊），但仔细想想发现这个 idea 居然还挺 novel 的。。。</p><ol><li>一种不同于 LSM 的 append only B+ 树存储引擎方案</li><li>不修改数据结构，天然无锁并发，不需要处理 B+ 树复杂的细粒度锁逻辑</li><li>可以在非叶节点上支持很多<strong>满足事务隔离要求</strong>的预聚合，不局限于分页</li><li>做 interval GC 很容易</li></ol><p>当然代价也是很明显的，<strong>写放大和空间放大前所未有的大</strong>，所以还是没有意义 ：）</p><p>好玩为主，很久没有 follow 过存储引擎的东西了，idea 如有雷同都是巧合（</p>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Database</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 const generics 实现类型安全的 Builder Pattern</title>
    <link href="/builder-pattern-with-const-generics/"/>
    <url>/builder-pattern-with-const-generics/</url>
    
    <content type="html"><![CDATA[<p>一篇搞笑文章 ：（</p><a id="more"></a><p><strong>Builder Pattern</strong></p><p><a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html">Builder Pattern</a> 是 rust 在复杂对象构造上推荐的一种设计模式，一个常见的 Builder 实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span> &#123;<br>    a: <span class="hljs-built_in">i32</span>,<br>    b: <span class="hljs-built_in">i32</span>,<br>    c: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(Default)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ABuilder</span></span> &#123;<br>    a_: <span class="hljs-built_in">i32</span>,<br>    b: <span class="hljs-built_in">i32</span>,<br>    c: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> ABuilder &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">a</span></span>(<span class="hljs-keyword">self</span>, a1: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">self</span>.a = a1;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">b</span></span>(<span class="hljs-keyword">self</span>, b1: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">self</span>.b = b1;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">c</span></span>(<span class="hljs-keyword">self</span>, c1: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">self</span>.c = c1;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">finish</span></span>(<span class="hljs-keyword">self</span>) -&gt; A &#123;<br>        A &#123;<br>            a: <span class="hljs-keyword">self</span>.a,<br>            b: <span class="hljs-keyword">self</span>.b,<br>            c: <span class="hljs-keyword">self</span>.c,<br>        &#125;<br>    &#125;&#125;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> crate::ABuilder;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_works</span></span>() &#123;<br>        <span class="hljs-keyword">let</span> _a = ABuilder::default().a(<span class="hljs-number">0</span>).c(<span class="hljs-number">0</span>).b(<span class="hljs-number">0</span>).finish();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>必选参数</strong></p><p>这时候我们接到了一些奇怪的需求，要把 a 和 b 作为必选参数（那为什么不把 a 和 b 传进 ABuilder::new 的参数呢，小编也很好奇，但是这么写就水不了文章了）。</p><p>我们可以为 ABuilder 引入三个 bit 的常量状态，标识每个参数是否被设置：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![feature(const_generics)]</span><br><span class="hljs-meta">#![feature(const_evaluatable_checked)]</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Assert</span></span>&lt;<span class="hljs-keyword">const</span> COND: <span class="hljs-built_in">bool</span>&gt; &#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">IsTrue</span></span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span> IsTrue <span class="hljs-keyword">for</span> Assert&lt;<span class="hljs-literal">true</span>&gt; &#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span> &#123;<br>    a: <span class="hljs-built_in">i32</span>,<br>    b: <span class="hljs-built_in">i32</span>,<br>    c: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(Default)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ABuilder</span></span>&lt;<span class="hljs-keyword">const</span> S: <span class="hljs-built_in">u64</span>&gt; &#123;<br>    a: <span class="hljs-built_in">i32</span>,<br>    b: <span class="hljs-built_in">i32</span>,<br>    c: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-keyword">const</span> S: <span class="hljs-built_in">u64</span>&gt; ABuilder&lt;S&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">a</span></span>(<span class="hljs-keyword">self</span>, a1: <span class="hljs-built_in">i32</span>) -&gt; ABuilder&lt;&#123;S | <span class="hljs-number">1</span>&#125;&gt; &#123;<br>        ABuilder::&lt;&#123;S | <span class="hljs-number">1</span>&#125;&gt; &#123;<br>            a: a1,<br>            b: <span class="hljs-keyword">self</span>.b,<br>            c: <span class="hljs-keyword">self</span>.c,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">b</span></span>(<span class="hljs-keyword">self</span>, b1: <span class="hljs-built_in">i32</span>) -&gt; ABuilder&lt;&#123;S | <span class="hljs-number">0b10</span>&#125;&gt; &#123;<br>        ABuilder::&lt;&#123;S | <span class="hljs-number">0b10</span>&#125;&gt; &#123;<br>            a: <span class="hljs-keyword">self</span>.a,<br>            b: b1,<br>            c: <span class="hljs-keyword">self</span>.c,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">c</span></span>(<span class="hljs-keyword">self</span>, c1: <span class="hljs-built_in">i32</span>) -&gt; ABuilder&lt;&#123;S | <span class="hljs-number">0b100</span>&#125;&gt; &#123;<br>        ABuilder::&lt;&#123;S | <span class="hljs-number">0b100</span>&#125;&gt; &#123;<br>            a: <span class="hljs-keyword">self</span>.a,<br>            b: <span class="hljs-keyword">self</span>.b,<br>            c: c1,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-keyword">const</span> S: <span class="hljs-built_in">u64</span>&gt; ABuilder&lt;S&gt; <span class="hljs-keyword">where</span> Assert::&lt;&#123;S &amp; <span class="hljs-number">0b110</span> == <span class="hljs-number">0b110</span>&#125;&gt;: IsTrue &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">finish</span></span>(<span class="hljs-keyword">self</span>) -&gt; A &#123;<br>        A &#123;<br>            a: <span class="hljs-keyword">self</span>.a,<br>            b: <span class="hljs-keyword">self</span>.b,<br>            c: <span class="hljs-keyword">self</span>.c,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> crate::ABuilder;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_works</span></span>() &#123;<br>        <span class="hljs-keyword">let</span> _a = ABuilder::&lt;<span class="hljs-number">0</span>&gt;::default().a(<span class="hljs-number">0</span>).c(<span class="hljs-number">0</span>).b(<span class="hljs-number">0</span>).finish();<br>        <span class="hljs-keyword">let</span> _b = ABuilder::&lt;<span class="hljs-number">0</span>&gt;::default().a(<span class="hljs-number">0</span>).c(<span class="hljs-number">0</span>).finish(); <span class="hljs-comment">// Compilation failed</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>迫于无奈，我们开了两个 incomplete feature 来做这个需求，一路顶着 warnings 编译成功了。</p><p>在上面的实现里，我们通过一个  <code>Assert</code> 的 trick，允许我们在 impl 的 block 上为常量参数 S 添加条件判断，而 S 本质上就是一个 bitflags，标识了某一个参数是否被设置过，为此我们仅为 <code>ABuilder&lt;S&gt; where Assert::&lt;&#123;S &amp; 0b110 == 0b110&#125;&gt;: IsTrue</code> 实现 finish 方法，这就满足了我们的需求。</p><p>报错大概长这样</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">error</span>[E0599]: the <span class="hljs-built_in">method</span> `finish` exists <span class="hljs-keyword">for</span> struct `ABuilder&lt;&#123;S | <span class="hljs-number">0b100</span>&#125;&gt;`, but its trait bounds were <span class="hljs-keyword">not</span> satisfied<br>  --&gt; src/lib.rs:<span class="hljs-number">70</span>:<span class="hljs-number">62</span><br>   |<br><span class="hljs-number">4</span>  | enum Assert&lt;const COND: bool&gt; &#123;&#125;<br>   | ----------------------------- doesn&#x27;t satisfy `Assert&lt;&#123;S &amp; <span class="hljs-number">0b110</span> == <span class="hljs-number">0b110</span>&#125;&gt;: IsTrue`<br>...<br><span class="hljs-number">17</span> | struct ABuilder&lt;const S: u64&gt; &#123;<br>   | ----------------------------- <span class="hljs-built_in">method</span> `finish` <span class="hljs-keyword">not</span> found <span class="hljs-keyword">for</span> this<br>...<br><span class="hljs-number">70</span> |         <span class="hljs-built_in">let</span> _b = ABuilder::&lt;<span class="hljs-number">0</span>&gt;::default().a(<span class="hljs-number">0</span>).c(<span class="hljs-number">0</span>).finish();<br>   |                                                     ^^^^^^ <span class="hljs-built_in">method</span> cannot be called on `ABuilder&lt;&#123;S | <span class="hljs-number">0b100</span>&#125;&gt;` due to unsatisfied trait bounds<br>   |<br>   = note: the following trait bounds were <span class="hljs-keyword">not</span> satisfied:<br>           `Assert&lt;&#123;S &amp; <span class="hljs-number">0b110</span> == <span class="hljs-number">0b110</span>&#125;&gt;: IsTrue`<br></code></pre></td></tr></table></figure><hr><p><strong>只能传递一次的参数</strong></p><p>此时我们又对 c 提了一些奇怪需求，我们希望 c 是可选参数，但是最多只会被传递一次（即 0 或 1 次）：</p><p>举一反三，这个需求太好改了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![feature(const_generics)]</span><br><span class="hljs-meta">#![feature(const_evaluatable_checked)]</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Assert</span></span>&lt;<span class="hljs-keyword">const</span> COND: <span class="hljs-built_in">bool</span>&gt; &#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">IsTrue</span></span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span> IsTrue <span class="hljs-keyword">for</span> Assert&lt;<span class="hljs-literal">true</span>&gt; &#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span> &#123;<br>    a: <span class="hljs-built_in">i32</span>,<br>    b: <span class="hljs-built_in">i32</span>,<br>    c: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(Default)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ABuilder</span></span>&lt;<span class="hljs-keyword">const</span> S: <span class="hljs-built_in">u64</span>&gt; &#123;<br>    a: <span class="hljs-built_in">i32</span>,<br>    b: <span class="hljs-built_in">i32</span>,<br>    c: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-keyword">const</span> S: <span class="hljs-built_in">u64</span>&gt; ABuilder&lt;S&gt; <span class="hljs-keyword">where</span> Assert::&lt;&#123;S &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>&#125;&gt;: IsTrue &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">a</span></span>(<span class="hljs-keyword">self</span>, a1: <span class="hljs-built_in">i32</span>) -&gt; ABuilder&lt;&#123;S | <span class="hljs-number">1</span>&#125;&gt; &#123;<br>        ABuilder::&lt;&#123;S | <span class="hljs-number">1</span>&#125;&gt; &#123;<br>            a: a1,<br>            b: <span class="hljs-keyword">self</span>.b,<br>            c: <span class="hljs-keyword">self</span>.c,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">b</span></span>(<span class="hljs-keyword">self</span>, b1: <span class="hljs-built_in">i32</span>) -&gt; ABuilder&lt;&#123;S | <span class="hljs-number">0b10</span>&#125;&gt; &#123;<br>        ABuilder::&lt;&#123;S | <span class="hljs-number">0b10</span>&#125;&gt; &#123;<br>            a: <span class="hljs-keyword">self</span>.a,<br>            b: b1,<br>            c: <span class="hljs-keyword">self</span>.c,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-keyword">const</span> S: <span class="hljs-built_in">u64</span>&gt; ABuilder&lt;S&gt; <span class="hljs-keyword">where</span> Assert::&lt;&#123;S &amp; <span class="hljs-number">0b100</span> == <span class="hljs-number">0</span>&#125;&gt;: IsTrue &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">c</span></span>(<span class="hljs-keyword">self</span>, c1: <span class="hljs-built_in">i32</span>) -&gt; ABuilder&lt;&#123;S | <span class="hljs-number">0b100</span>&#125;&gt; &#123;<br>        ABuilder::&lt;&#123;S | <span class="hljs-number">0b100</span>&#125;&gt; &#123;<br>            a: <span class="hljs-keyword">self</span>.a,<br>            b: <span class="hljs-keyword">self</span>.b,<br>            c: c1,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-keyword">const</span> S: <span class="hljs-built_in">u64</span>&gt; ABuilder&lt;S&gt; <span class="hljs-keyword">where</span> Assert::&lt;&#123;S &amp; <span class="hljs-number">0b110</span> == <span class="hljs-number">0b110</span>&#125;&gt;: IsTrue &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">finish</span></span>(<span class="hljs-keyword">self</span>) -&gt; A &#123;<br>        A &#123;<br>            a: <span class="hljs-keyword">self</span>.a,<br>            b: <span class="hljs-keyword">self</span>.b,<br>            c: <span class="hljs-keyword">self</span>.c,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> crate::ABuilder;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_works</span></span>() &#123;<br>        <span class="hljs-keyword">let</span> _a = ABuilder::&lt;<span class="hljs-number">0</span>&gt;::default().a(<span class="hljs-number">1</span>).b(<span class="hljs-number">1</span>).c(<span class="hljs-number">1</span>).finish();<br>        <span class="hljs-comment">// let _b = ABuilder::&lt;0&gt;::default().a(1).c(1).c(1).b(1).finish();</span><br>        <span class="hljs-comment">// let _c = ABuilder::&lt;0&gt;::default().a(1).c(1).finish();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><p>这确实是一篇搞笑文章，所有需求都是我在学习 const generics 先进语法的时候随便做的实验，事实上 Builder Pattern 并不适用于这些奇怪的需求，而且用到了 <code>const_evaluatable_checked</code> 这种纸糊的 feature 也不可能用于生产。有一个真正用于生产的 crate <a href="https://github.com/idanarye/rust-typed-builder">typed-builder</a> 思路跟我类似，不过直接生成了一个长度为 n （n 为 fields 的数量）的 tuple 来记录状态，更合理一些。不过基于 <code>const_evaluatable_checked</code> 可以实现很多奇奇怪怪的需求，比如可以做编译期状态压缩 DP（rustc 爆炸中），还可以做一些奇奇怪怪的限制（比如限制一个方法最少被调用 n 次，最多被调用 m 次，完全想不到什么场景需要），可以认为是对 Rust typesafe state machine 能力的一个强化了，对于一些比较相似的状态转换过程，我们可以直接基于 const generics 来减少重复代码（DRY）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Copy &amp; Paste 三行代码让 TiDB 性能翻倍</title>
    <link href="/tidb-2-times-faster/"/>
    <url>/tidb-2-times-faster/</url>
    
    <content type="html"><![CDATA[<p>标题党，今天给 TiDB 水了个有意思的 PR，随便写个 blog 记录一下。<strong>文末粉丝福利</strong></p><a id="more"></a><p>上午摸鱼的时候，读了雷宇哥哥的文章 <a href="https://internals.tidb.io/t/topic/174">I beat TiDB with 20 LOC</a>，这篇文章非常有意思，推荐 go 吹/go 黑都可以读一读，通过这篇文章，我发现了 cgo 比想象的要快很多，以及 go 编译器比想象更烂，以至于 cgo 的 overhead 完全抵消了还不够。在学习 TiDB 先进经验的时候，看到了一段有意思的代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *builtinArithmeticPlusIntSig)</span> <span class="hljs-title">plusSS</span><span class="hljs-params">(result *chunk.Column, lhi64s, rhi64s, resulti64s []<span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(lhi64s); i++ &#123;<br>        <span class="hljs-keyword">if</span> result.IsNull(i) &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        lh, rh := lhi64s[i], rhi64s[i]<br>        <span class="hljs-keyword">if</span> (lh &gt; <span class="hljs-number">0</span> &amp;&amp; rh &gt; math.MaxInt64-lh) || (lh &lt; <span class="hljs-number">0</span> &amp;&amp; rh &lt; math.MinInt64-lh) &#123;<br>            <span class="hljs-keyword">return</span> types.ErrOverflow.GenWithStackByArgs(<span class="hljs-string">&quot;BIGINT&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;(%s + %s)&quot;</span>, b.args[<span class="hljs-number">0</span>].String(), b.args[<span class="hljs-number">1</span>].String()))<br>        &#125;<br><br>        resulti64s[i] = lh + rh<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>要理解这段代码，首先我们需要理解什么是 chunk。chunk 是一种列式内存格式，是 <a href="https://arrow.apache.org/">Apache Arrow</a> 的一种实现，具体可以参考 <a href="https://pingcap.com/blog-cn/tidb-source-code-reading-10/">TiDB 源码阅读系列文章（十）Chunk 和执行框架简介</a>。对于这里的 Int 类型，Column 的内部其实是一个 int64 array 和一个 bitmap。</p><p><img src="https://download.pingcap.com/images/blog-cn/tidb-source-code-reading-10/1.png" alt="Int64Column 的实现"></p><p>这段代码的目的就是将 lhi64s 和 rhi64s 加和的结果保存到 resulti64s 中。为了彻底理解这段代码，我们还需要关注一下调用它的函数 <code>builtinArithmeticPlusIntSig.vecEvalInt</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *builtinArithmeticPlusIntSig)</span> <span class="hljs-title">vecEvalInt</span><span class="hljs-params">(input *chunk.Chunk, result *chunk.Column)</span> <span class="hljs-title">error</span></span> &#123;<br>n := input.NumRows()<br><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// Calculate lh and rh</span><br>result.MergeNulls(lh)<br>result.MergeNulls(rh)<br><br>lhi64s := lh.Int64s()<br>rhi64s := rh.Int64s()<br>resulti64s := result.Int64s()<br><br>isLHSUnsigned := mysql.HasUnsignedFlag(b.args[<span class="hljs-number">0</span>].GetType().Flag)<br>isRHSUnsigned := mysql.HasUnsignedFlag(b.args[<span class="hljs-number">1</span>].GetType().Flag)<br><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> isLHSUnsigned &amp;&amp; isRHSUnsigned:<br>err = b.plusUU(result, lhi64s, rhi64s, resulti64s)<br><span class="hljs-keyword">case</span> isLHSUnsigned &amp;&amp; !isRHSUnsigned:<br>err = b.plusUS(result, lhi64s, rhi64s, resulti64s)<br><span class="hljs-keyword">case</span> !isLHSUnsigned &amp;&amp; isRHSUnsigned:<br>err = b.plusSU(result, lhi64s, rhi64s, resulti64s)<br><span class="hljs-keyword">case</span> !isLHSUnsigned &amp;&amp; !isRHSUnsigned:<br>err = b.plusSS(result, lhi64s, rhi64s, resulti64s)<br>&#125;<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码主要是根据加法算子两侧表达式的类型，决定调用具体的实现，而 plusSS 则是其中的一种（两个有符号整数相加）。但在调用具体的实现之前，已经对 lh 和 rh 分别调用了 <code>result.MergeNulls()</code>，因此在 <code>plusSS</code> 中只需要对 result 是否为空进行判断，决定是否跳过计算。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">if</span> result.IsNull(i) &#123;<br>    <span class="hljs-keyword">continue</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">if</span> (lh &gt; <span class="hljs-number">0</span> &amp;&amp; rh &gt; math.MaxInt64-lh) || (lh &lt; <span class="hljs-number">0</span> &amp;&amp; rh &lt; math.MinInt64-lh) &#123;<br>    <span class="hljs-keyword">return</span> types.ErrOverflow.GenWithStackByArgs(<span class="hljs-string">&quot;BIGINT&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;(%s + %s)&quot;</span>, b.args[<span class="hljs-number">0</span>].String(), b.args[<span class="hljs-number">1</span>].String()))<br>&#125;<br></code></pre></td></tr></table></figure><p>理解剩下的代码就非常直观了，做一个 overflow 判断，然后返回相加的结果。这也是针对不同符号的 Plus 函数最大的区别。</p><p>在 MySQL 大部分 expression 的逻辑，对于输入参数包含 NULL 的情况，输出参数往往也是 NULL，TiKV 为了 DRY，<a href="https://github.com/tikv/tikv/pull/8331/files">使用宏简化了这个逻辑</a>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[rpn_fn]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">like</span></span>&lt;C: Collator&gt;(target: BytesRef, pattern: BytesRef, escape: &amp;<span class="hljs-built_in">i64</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i64</span>&gt;&gt; &#123;<br>    <span class="hljs-literal">Ok</span>(<span class="hljs-literal">Some</span>(<br>        like::like::&lt;C&gt;(target, pattern, *escape <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>)? <span class="hljs-keyword">as</span> <span class="hljs-built_in">i64</span><br>    ))<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码进行宏展开后和上面的 go 代码类似，如果参数有 null 的情况会直接跳过真实 like 的调用。但对于 Plus 这种基础的数学运算函数，事情就有了一些变化。一个常识是，分支的代价其实比 add 这种基础指令大很多，在高效的列式执行逻辑里，这里引入了两个 branch 操作，相比于运算（一次 add）本身来说，这两个 branch 才是最大的 overhead。</p><p>且这两个 branch 是必要的 check，同时也是 unlikely 的（大概率会走 else 分支）。在完全不改变代码逻辑的情况下，我们可以<a href="https://github.com/pingcap/tidb/pull/25466">将它们优化成一个 branch</a>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *builtinArithmeticPlusIntSig)</span> <span class="hljs-title">plusSS</span><span class="hljs-params">(result *chunk.Column, lhi64s, rhi64s, resulti64s []<span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(lhi64s); i++ &#123;<br>lh, rh := lhi64s[i], rhi64s[i]<br><br><span class="hljs-keyword">if</span> (lh &gt; <span class="hljs-number">0</span> &amp;&amp; rh &gt; math.MaxInt64-lh) || (lh &lt; <span class="hljs-number">0</span> &amp;&amp; rh &lt; math.MinInt64-lh) &#123;<br><span class="hljs-keyword">if</span> result.IsNull(i) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">return</span> types.ErrOverflow.GenWithStackByArgs(<span class="hljs-string">&quot;BIGINT&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;(%s + %s)&quot;</span>, b.args[<span class="hljs-number">0</span>].String(), b.args[<span class="hljs-number">1</span>].String()))<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>是的，代码改动只有三行，且只是原封不动 Copy &amp; Paste（点题），我们来看看 benchmark 的结果。TiDB 非常贴心地提供了表达式模块的 benchmark 脚本，我们可以直接使用：</p><p><img src="https://user-images.githubusercontent.com/9161438/125152817-e68d9000-e181-11eb-970d-ba39ed400017.png" alt="Benchmark PlusInt"></p><p>可以看到，四种函数的提升都是非常可观的。其中第一个 Case 更是直接性能翻倍。</p><p>这个优化的原理是非常简单的，<code>Plus</code> 这种基础函数满足两个特性：</p><ol><li>运算本身比 check 轻量。</li><li>运算不会 crash，且没有副作用。</li></ol><p>那么我们可以直接删除 null check 的三行代码，因为 null 的结果已经被写到 result 的 bitmap 里了，这里无脑做一下计算就可以。但由于 overflow check 的存在，我们不能返回非预期的 overflow 错误（可以说 plus 运算本身无状态，overflow check 引入了状态），因此如果发生了 overflow 的话，我们得确认本身不是 null，如果确认不是 null 的话，才返回错误。从某种意义上，这个优化可以认为是手动帮 CPU 做流水线执行。</p><hr><p><img src="https://user-images.githubusercontent.com/9161438/125152990-49335b80-e183-11eb-82cb-dc800574c956.png" alt=""></p><p>上面的 PR 是我花十分钟写的，我是想再给力一点的，但是懒（躺），下面只说失败的尝试和思路。</p><p>首先是想办法优化掉 overflow check 的 branch，我先把 overflow check 的 branch 提取到外侧：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *builtinArithmeticPlusIntSig)</span> <span class="hljs-title">plusSS</span><span class="hljs-params">(result *chunk.Column, lhi64s, rhi64s, resulti64s []<span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>+       <span class="hljs-keyword">var</span> hasOverflow <span class="hljs-keyword">int64</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(lhi64s); i++ &#123;<br>                lh, rh := lhi64s[i], rhi64s[i]<br><br>-               <span class="hljs-keyword">if</span> (lh &gt; <span class="hljs-number">0</span> &amp;&amp; rh &gt; math.MaxInt64-lh) || (lh &lt; <span class="hljs-number">0</span> &amp;&amp; rh &lt; math.MinInt64-lh) &#123;<br>-                       <span class="hljs-keyword">if</span> result.IsNull(i) &#123;<br>-                               <span class="hljs-keyword">continue</span><br>-                       &#125;<br>-                       <span class="hljs-keyword">return</span> types.ErrOverflow.GenWithStackByArgs(<span class="hljs-string">&quot;BIGINT&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;(%s + %s)&quot;</span>, b.args[<span class="hljs-number">0</span>].String(), b.args[<span class="hljs-number">1</span>].String()))<br>-               &#125;<br>-<br>+               hasOverflow |= (b2i(lh &gt; <span class="hljs-number">0</span>) &amp; b2i(rh &gt; math.MaxInt64-lh)) | (b2i(lh &lt; <span class="hljs-number">0</span>)&amp;b2i(rh &lt; math.MinInt64-lh))&amp;b2iNot(result.IsNull(i))<br>                resulti64s[i] = lh + rh<br>        &#125;<br>+<br>+       <span class="hljs-keyword">if</span> <span class="hljs-keyword">uint64</span>(hasOverflow) &gt; <span class="hljs-number">0</span> &#123;<br>+               <span class="hljs-keyword">return</span> types.ErrOverflow.GenWithStackByArgs(<span class="hljs-string">&quot;BIGINT&quot;</span>, <span class="hljs-string">&quot;overflow&quot;</span>)<br>+       &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br> &#125;<br></code></pre></td></tr></table></figure><p>这个优化对逻辑是有变更的，因为报错信息里没法输出正确的数字了，但也不是完全没有办法，考虑到 overflow 是小概率事件，我们可以发现 overflow 以后再循环一次，拿到具体 overflow 的数字。</p><p><code>b2i</code> 和 <code>b2iNot</code> 大概就是 bool2Int，具体懒得贴了，反正大道至简不需要解释。实测效果大概 benchmark 低了一倍，我又懒得看汇编调优（下次高兴了再水一篇 blog）。猜测有几个原因：</p><ol><li>Overflow check 比较重，原来可以短路求值的计算现在强制计算了，代价超过了 branch 运算。</li><li>Go 的优化比较拉，我写的位运算也比较拉。</li></ol><p>但总之想优化掉 overflow check 是一件 non-trivial 的事情，</p><p>既然解决不了问题，我们不妨解决提问题的人。对于 AP 性能有极致追求的用户，我们可以提供某种 non-strict sql_mode，允许整型 overflow，结果是未定义的，这样我们就能自由地去掉 check 了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 这里已经不需要四种符号的版本了</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *builtinArithmeticPlusIntSig)</span> <span class="hljs-title">plusNonStrict</span><span class="hljs-params">(result *chunk.Column, lhi64s, rhi64s, resulti64s []<span class="hljs-keyword">int64</span>)</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(lhi64s); i++ &#123;<br>                lh, rh := lhi64s[i], rhi64s[i]<br>                resulti64s[i] = lh + rh<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;&#125;<br></code></pre></td></tr></table></figure><hr><p><img src="https://user-images.githubusercontent.com/9161438/125152990-49335b80-e183-11eb-82cb-dc800574c956.png" alt=""></p><p>能啊，直接看雷宇哥哥文章的 SIMD 版本 <a href="https://internals.tidb.io/t/topic/174">I beat TiDB with 20 LOC</a>。</p><p>只能说，TiDB 的 Executor 还有很长的路要走（</p><hr><p><strong>你是不是标题党？这哪里提升两倍了？</strong></p><p>是，expression 的 benchmark 翻倍，但在整个 SQL 的生命流程中只是微不足道的一部分，特别是 TP 的请求。即使对于复杂的 AP 请求，除非是完全从本地节点的 cache memory engine 中读取的数据，否则相同的数据量网络开销大概率也会超过这部分的优化效果（特别是 TiDB 和 TIKV 交互还用的 gRPC，那就更拉了）。</p><hr><p>说好的福利（伪）：我改完 Plus 就懒得改了，目测 Sub/And/Or/Not/Xor/… 肯定都能提升的，Mul/Div/Mod 可能需要 benchmark 一下才知道有没有提升，同时 TiKV 上也可以水一堆，感兴趣的可以去水一个 PR 薅 TiDB 的 new contributor 周边杯子。有能力的也可以把 non-strict Plus 实现一下（也很 trivial，就是要思考一下用户接口）。</p><!--option = {    title: {        text: 'PlusInt',        subtext: ''    },    tooltip: {        trigger: 'axis'    },    legend: {        data: ['优化前', '优化后']    },    toolbox: {        show: true,        feature: {            dataView: {show: false, readOnly: false},            magicType: {show: false, type: ['line', 'bar']},            restore: {show: false},            saveAsImage: {show: true}        }    },    calculable: true,    xAxis: [        {            type: 'category',            data: ['VecBuiltinFunc-12', 'VecBuiltinFunc#01-12', 'VecBuiltinFunc#02-12', 'VecBuiltinFunc#03-12']        }    ],    yAxis: [        {            type: 'value'        }    ],    series: [        {            name: '优化前',            type: 'bar',            data: [251072, 505320, 446617, 375538],            markPoint: {                data: [                    {type: 'max', name: '最大值'},                    {type: 'min', name: '最小值'}                ]            },        },        {            name: '优化后',            type: 'bar',            data: [537535, 806791, 487568, 442723],            markPoint: {                data: [                    {name: '年最高', value: 182.2, xAxis: 7, yAxis: 183},                    {name: '年最低', value: 2.3, xAxis: 11, yAxis: 3}                ]            },        }    ]};-->]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Database</tag>
      
      <tag>TiDB</tag>
      
      <tag>Open Source</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五一摸鱼周记：更新 Blog 主题、水 PR</title>
    <link href="/update-blog-theme/"/>
    <url>/update-blog-theme/</url>
    
    <content type="html"><![CDATA[<p>灌水一篇，这篇文章会介绍：</p><ul><li>更新Blog主题的<strong>底层逻辑</strong></li><li>利用 vercel serverless <strong>赋能</strong> blog 的 slogan</li><li>打好 hexo-fluid-theme 和 cusdis 的<strong>组合拳</strong></li><li><strong>反哺</strong> cusdis 的生态</li></ul><p>🐶狗头保命</p><a id="more"></a><p>更新 blog 主题是一个比写 blog 文章快乐多了的事情，这也是 blog 新手常常陷入的一个陷阱 —— 精心配置一整天的主题、评论、评论、插件，然后写下一篇 类似于 Hello World 的《使用XXX 搭建 blog》之后从此吃灰。为了避免自己陷入这个陷阱，我搭 blog 的时候给自己定下了一个规则 —— <strong>每次写一篇文章才能更新一次与文章无关的 blog 配置</strong>。</p><p>最终的结果是 —— 我既没有保持合适的更新频率，也没机会折腾主题，直接使用了烂大街的 <a href="https://github.com/theme-next/hexo-theme-next">hexo next</a>，没有评论，没有 Analytics，甚至连 Hello World 都没写，创造了一个三无 blog。</p><p>直到今年开始，我成功更新了两篇文章（这里非常感谢  <a href="https://taio.app">Taio App</a>，让我在手机上也能快乐地写 blog），适当地让 blog 更易用一些也提上了日程</p><p>第一件事情自然是喜闻乐见的换皮，选了<br><a href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-fluid-theme</a>，就觉得挺好看的，配置也比较完善，代码也不复杂，看了看感觉如果有必要的话（其实很快就有必要了），我自己也改得动。</p><p>配置的过程中，遇到了两个麻烦，一个是这个主题必须配置一个 banner_img，而且默认的太丑了，于是为了提高辨识度，我随手画了一个更丑的，以后有机会再优化（下次一定）。另一个是主页上要求写一个 slogan，我想把 <a href="https://github.com/TennyZhuang/Chi-Corpus">迟语录 chi_corpus</a> 随机显示在主页上，但是 hexo-fluid-theme 只支持 json 格式，即使我 commit 一个 json 格式上去，也没法做到随机返回，独立维护一个转换服务又会极大增加我的运维负担，因此动了薅 vercel 羊毛的心思。翻了翻 <a href="https://vercel.com/docs/serverless-functions/introduction">vercel serverless</a> 的使用文档，感觉使用起来非常简单，而事实上也是如此。仅仅是花了五分钟，添加一个四十行的 go 文件，我就轻松达到了我的目的。可以在<a href="/">首页</a>观看效果。赞美 vercel（*1）！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> CHI_CORPUS_URL = <span class="hljs-string">&quot;https://raw.githubusercontent.com/TennyZhuang/Chi-Corpus/master/common.txt&quot;</span><br><br><span class="hljs-keyword">type</span> Data <span class="hljs-keyword">struct</span> &#123;<br>Content <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;content&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetchChiCorpus</span><span class="hljs-params">()</span> <span class="hljs-params">(*Data, error)</span></span> &#123;<br>resp, err := http.Get(CHI_CORPUS_URL)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br>body, err := ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>content := <span class="hljs-keyword">string</span>(body)<br>lines := strings.Split(content, <span class="hljs-string">&quot;\n&quot;</span>)<br>line := lines[rand.Intn(<span class="hljs-built_in">len</span>(lines))]<br><span class="hljs-keyword">return</span> &amp;Data&#123;<br>Content: line,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>data, err := fetchChiCorpus()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>w.WriteHeader(http.StatusInternalServerError)<br>w.Write([]<span class="hljs-keyword">byte</span>(err.Error()))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json; charset=utf-8&quot;</span>)<br>json.NewEncoder(w).Encode(data)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本来鸽子博主已经决定更新到这里结束了，看了推友 <a href="https://twitter.com/frostming90?s=21">@frostming90</a> 的 <a href="https://frostming.com/2021/04-28/self-host-comment-system/">blog</a>（别人的 blog 真好看啊），于是进行了一番抄作业。再吹一次，vercel 真的好用（*2），无脑就把一个 blog 后台跑起来了，而且还是白嫖。这次遇到一个新问题，就是 hexo-fluid-theme 支持了许多 comment plugin，但还不支持 cusdis。顺手 fork 了一个支持了一下，顺便提了个 PR <a href="https://github.com/fluid-dev/hexo-theme-fluid/pull/474">https://github.com/fluid-dev/hexo-theme-fluid/pull/474</a>。目前 console 里还有个奇妙的报错 <code>Function called outside component initialization</code>，但似乎不影响 plugin 的使用，有知道怎么修的也可以带带我，前端技能不太熟练了：（</p><p>目前对 cusdis 还有一些小小的问题，比如评论仅支持审核后显示，似乎不支持默认显示的方式，使用起来比较麻烦，后续考虑 contribute 一下。欢迎试用新整的评论系统～</p><p>个人搭建并维护 blog 还是比较麻烦的事情，一个关键技巧是在<strong>掌控数据</strong>的前提下尽可能依赖第三方服务。这次的整套组合拳打下来基本也就花了半天的时间在折腾（没有 vercel 可能一天起步了，点赞*3），但数据是以可以掌控的格式（postgresql，可以自己备份）存储的。考虑到 <a href="https://www.45office.com">Donald Trump 被封禁到搭建了自己的个人博客</a>，可见 blog 这种去中心化的组织形式还是有必要的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>Water</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解锁 TiDB Hackathon 一等奖的新体验：TiDB + Wasm</title>
    <link href="/tidb-hackathon-2020/"/>
    <url>/tidb-hackathon-2020/</url>
    
    <content type="html"><![CDATA[<p>前段时间，因为比较活跃在 TiDB 社区，所以顺手参加了 TiDB 2020 Hackathon。这次选的参赛题目是一个老生常谈的功能：UDF（User Defined Function）。</p><a id="more"></a><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>尽管是完全与安全方向无关的主题，但我们随手取了个队名 ‘ or 0=0 or ‘（读作「引号or零等于零or引号」），除了可以卖萌，而且还能用于 SQL 注入，感兴趣的可以看看<a href="https://zhuanlan.zhihu.com/p/24471576">万能密码</a>这个 topic。很意外的是还引发了 hackathon 过程中一个有趣的小插曲，在看到我们的队名后东旭和姚老板纷纷吐槽太有年代感了：</p><p><img src="https://user-images.githubusercontent.com/9161438/111075420-e4dcf400-8522-11eb-8203-b9b834926bbc.png" alt="年代感.jpg"></p><p>但仅仅过了半天，在我们 hack 的途中，我们的队友 breeswish 就无意中发现 TiDB 的内部 SQL 存在原始的字符串拼接参数且没有校验参数合法性，成功地进行了一次提权攻击 ：D</p><p><img src="https://user-images.githubusercontent.com/9161438/111075565-8fedad80-8523-11eb-9fe9-9bdee5a54435.PNG" alt="提权注入成功"></p><h2 id="我们想做什么？"><a href="#我们想做什么？" class="headerlink" title="我们想做什么？"></a>我们想做什么？</h2><p>每年的 TiDB Hackathon 其实都会有 UDF 的 proposal，这里面也包括我在 2018 年参赛时实现的基于 lua 的 UDF。当时的实现非常粗糙，我们在 TiDB/TiKV 上直接起了一个 lua vm，然后允许用户以 CREATE FUNCTION 的语法把 lua 函数上传到 TiDB 并保存在 PD，同时支持用户通过 <code>call_lua(fn_name, args)</code> 的语法来调用 UDF。TiDB/TiKV 的执行器会从 PD 加载函数 body，并通过 lua vm 执行。这个方案有许多问题，以至于只能是一个 demo，始终无法落地：</p><ol><li>lua 生态较差，仅适用于实现一些功能简单的函数。而类似方法支持更多语言需要 TiDB 内置多种 vm。</li><li>与 vm  的交互开销较高，UDF lua 相比 native 函数，执行效率偏低。</li></ol><p>lua UDF 这个项目也因此很遗憾没有拿奖。<del>一个没被采用的队名：MAKE UDF GREAT AGAIN!</del></p><p>得益于 TiDB 本身是开源的，有 UDF 需求的用户可以通过修改源码的方式（非常简单），添加自定义函数并自行部署。然而随着 Cloud Native 时代的到来，DBaaS 成为了越来越多用户使用数据库的方式，这种方式不再适用 —— 公有云用户无法修改 TiDB/TiKV 的二进制文件。在 2020 TiDB Hackathon 选题的时候，我们又把这个 topic 重新捡了起来，与之前不同的是，这次我们不再是 idea driven hackathon，更多关注的是方案可落地，<strong>让 UDF 这个选题从未来的 Hackathon 中消失</strong>，在设计之初，我们就定下了若干目标：</p><ol><li>灵活性：应该支持更多的编程语言进行 UDF 的编写。不同人对编程语言的喜好大相庭径，强迫 TiDB 的用户使用 lua 编写 UDF 并不是一种优美的做法。</li><li>安全性：数据库的安全性至关重要，应该保证函数在沙箱环境运行，不能造成权限泄漏，也应该尽可能减少对业务稳定性的影响。</li><li>高效性：性能接近 Native 函数，用户不需要担心额外的 overhead。</li><li>功能：在保证安全的前提下，提供数据库内部的 API 以及对外的网络 API 到 UDF 的沙箱环境，同时这些 API 也在权限控制的管理下。</li></ol><h2 id="我们做了什么？"><a href="#我们做了什么？" class="headerlink" title="我们做了什么？"></a>我们做了什么？</h2><p>为了不引入过多过重的 runtime，增加维护的心智负担，我们选择了 Wasm 作为解决方案。Wasm 本身我不过多介绍了，感兴趣的同学可以在很多地方找到详细的介绍。最关键的是，Wasm 拥有我们想要的所有 feature。Wasm 是面向浏览器的沙箱环境安全执行设计的一种 low-level 指令，同时也兼备接近 native 代码的高性能，之后也被扩展到非浏览器的平台运行。（其实我觉得这玩意早该有了，但确实还是要依赖各大巨头合作才能定义出一套大家都接受的标准）</p><p>选定了 Wasm 作为技术方案以后，剩下的工作就是选择一个合适的 runtime，并且嵌入到 TiDB/TiKV 的执行器中。由于同时需要兼容 C、Go、Rust 语言，我们选择了 <a href="https://wasmer.io/">Wasmer</a> 作为我们 demo 时的 runtime，并且使用了 llvm backend 达到了接近 native 的性能。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;emscripten/emscripten.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> EMSCRIPTEN_KEEPALIVE</span><br><span class="hljs-function"><span class="hljs-title">udf_main</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> a, <span class="hljs-keyword">uint64_t</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设用户先基于 emscripten 工具链实现了一个简单的函数 aplusb，由于这里的类型完全是 Wasm 原生类型，因此也不需要做任何额外的处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ emcc aplusb.c -O3 -o aplusb.wasm --no-entry -s ERROR_ON_UNDEFINED_SYMBOLS=0<br><span class="hljs-comment"># 由于 Wasm 是一种 binary 的格式，我们做了一些简单的处理</span><br>$ cat aplusb.wasm | od -v -t x1 -A n | tr -d <span class="hljs-string">&#x27; \n&#x27;</span><br>0061736d010000000117056000017f60000060017f0060017f017f60027e7e017e0307060104000203000405017001020205060101800280020609017f01419088c0020b077a08066d656d6f72790200087564665f6d61696e0001195f5f696e6469726563745f66756e6374696f6e5f7461626c6501000b5f696e697469616c697a650000105f5f6572726e6f5f6c6f636174696f6e000509737461636b5361766500020c737461636b526573746f726500030a737461636b416c6c6f6300040907010041010b01000a30060300010b0700200020017c0b040023000b0600200024000b1000230020006b4170712200240020000b05004180080b<br></code></pre></td></tr></table></figure><p>用户可以通过 CREATE FUNCTION 命令将这段 wasm bytecode 传给 TiDB：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; CREATE FUNCTION aplusb WASM_BYTECODE x&quot;0061736d010000000117056000017f60000060017f0060017f017f60027e7e017e0307060104000203000405017001020205060101800280020609017f01419088c0020b077a08066d656d6f72790200087564665f6d61696e0001195f5f696e6469726563745f66756e6374696f6e5f7461626c6501000b5f696e697469616c697a650000105f5f6572726e6f5f6c6f636174696f6e000509737461636b5361766500020c737461636b526573746f726500030a737461636b416c6c6f6300040907010041010b01000a30060300010b0700200020017c0b040023000b0600200024000b1000230020006b4170712200240020000b05004180080b&quot;;<br>Query OK, 0 rows affected (0.33 sec)<br><br><span class="hljs-section">mysql&gt; SELECT aplusb(1, 4);</span><br><span class="hljs-section">+--------------+</span><br><span class="hljs-section">| aplusb(1, 4) |</span><br><span class="hljs-section">+--------------+</span><br><span class="hljs-section">|            5 |</span><br><span class="hljs-section">+--------------+</span><br><br>mysql&gt; SELECT aplusb();<br>ERROR 1582 (42000): Incorrect parameter count in the call to native function <span class="hljs-emphasis">&#x27;aplusb&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/9161438/115414212-6d3c6c00-a228-11eb-889d-8f2c83e10335.png" alt="image"></p><p>创建后，UDF 的 Wasm bytecode 会被存在一张系统表中，在某个节点首次执行后会被编译执行并且缓存在该节点上。</p><p>当然对于大段的 bytecode，这种方式其实不友好，可能后续需要提供一些上传工具。（不过这并不是 hack 需要考虑的事情</p><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>我们分别用 Wasm UDF 和 TiDB/TiKV native code 实现了一个叫 [nbody](<a href="https://github.com/tidb-hackathon-2020-wasm-udf/tidb/commit/bbcf0d5748a6462e1030bca07b30d848ea250648">add builtin nbody · tidb-hackathon-2020-wasm-udf/tidb@bbcf0d5 (github.com)</a>) 的函数用作性能测试。我们很意外地发现 UDF nbody 比 rust nbody 大致相近（符合预期），但居然比 go nbody 快一些 <del>（说明 golang 辣鸡）</del>，猜测是 allocator 的问题。这个实验也充分证明了 UDF 的高性能。</p><h4 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h4><p>这其实是我们在 Wasm 上踩坑最多的地方，Wasm 的接口比较 low level，因此一些高级语言的数据结构（其实从需求上来说主要就是 string）映射到 Wasm ABI 会有不同的表示，我们还是需要为每种语言定制一下工具链来生成符合我们预期的 Wasm bytecode。</p><p>我们分别用 rust/golang/C 实现了 UDF 的功能，在尝试 Java 时，我们踩了比较大的坑，感觉 Java compile to Wasm 的工具链都比较不成熟。目前来看，Wasm 生态比较好的其实是运行时更轻量的静态语言。</p><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p><img src="https://user-images.githubusercontent.com/9161438/115404999-6b6eaa80-a220-11eb-8472-d2b28080b2ff.png" alt="execution"></p><p>Wasm 本身是个安全的沙箱执行环境，我们可以主动提供一些 API 给用户调用，并且配合权限认证。为了演示这个功能，我们实现了一个 HTTPGet 的函数，同时对接了 TiDB 本身的 Privilege 系统 —— 有 UDFNetworkPrivilege 权限的用户才能顺利创建和执行这个函数。这其实给 TiDB 与云生态结合提供了很大的想象空间。</p><hr><p>最后我们在 Demo 的时候演示了一个非常 fancy 的东西：我们复用了上一届 Hackathon 二等奖的一个成果，他们做的是<a href="https://pingcap.com/blog-cn/tidb-in-the-browser-running-a-golang-database-on-wasm/">基于 Wasm 让TiDB 运行在浏览器里</a>，然后我们直接复用他们的 Wasm 实现了<strong>让 TiDB 跑在 TiDB 里</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"># TiDB 套娃<br><span class="hljs-keyword">SELECT</span> wasm_tidb(<span class="hljs-string">&#x27;SELECT tidb_version();&#x27;</span>);<br><span class="hljs-keyword">SELECT</span> wasm_tidb(<span class="hljs-string">&#x27;use test; create table t1 (id int primary key); insert into t1 values (1); select * from t1;&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="Not-only-UDF"><a href="#Not-only-UDF" class="headerlink" title="Not only UDF"></a>Not only UDF</h2><p>我们的参赛主题写的是 TOT（TiDB over TIDB），事实上我一开始是想展示三种 TOT 的 demo（很遗憾的是我们最后只实现了两种）：</p><ol><li>TiDB 通过 UDF 访问云上的另一个 TiDB，展示 UDF 可以提供受沙箱限制的网络能力，为云上和其他服务联动提供想象空间。</li><li>TiDB 通过 UDF 运行另一个编译成Wasm 的 TiDB，展示 wadm 强大的可扩展性，我们甚至可以把 TiDB 本身移植上去（见上文）。</li><li><strong>在 UDF 中暴露受控的合适的内部接口，例如执行一些查询/修改，达到类似存储过程的效果。</strong></li></ol><p>至少在互联网公司的数据库应用中，存储过程已经是基本被抛弃的功能。存储过程有很多众所周知的缺点：</p><ul><li>语法和主流语言有差异，且缺乏统一标准，难以 port 到其他架构</li><li>通常表达能力较弱，容易写错</li><li>难以根据业务模型封装</li><li>占用数据库计算资源，难以控制存储过程的复杂度，容易把 DB 打挂</li><li>……</li></ul><p>而基于 Wasm 的存储过程，可以基本避免上面提到的缺点：</p><ul><li>不再拘泥于特定的 DSL，凡是能编译到 Wasm 的语言都能运行在 DB 上，业务很容易 port 代码，且 GPL（general purpose language）的表达能力通常比 DSL 强大很多。</li><li>运行在各种架构上，一处编码处处运行（JVM：？）</li><li>借助 jit 达到接近 native 的性能，特别是如果 DB 本身是基于 query compilation 的执行器的话，可以把整个 query 的完整执行逻辑直接编译成媲美手写的最佳性能。（当然 TiDB 不行）</li><li>借助 Wasm 本身的沙盒机制保证安全性。</li></ul><p>这样自由又强大的 ”存储过程“ 已经接近于数据库内部的 Serverless 了，相比直接用 Serverless ，做在数据库内部有什么好处，这又是另一个很大的 topic 了，下次有灵感了再写（🕊）。</p><p>最近经常学习 Manjusaka 老师的 Blog，感受了 ePBF 给内核可观测性带来的变化。事实上 Wasm 也可以做到类似的事情。除了实现存储过程，Wasm 还可以用于用户自定义 Trigger。这个 Trigger 不仅仅可以在数据修改时执行，在如获取 TSO，下推计算、数据复制，等所有具有观测价值的地方都可以进行一些埋点对 UDF 调用，而在 UDF 内部可以灵活高效地采集监控信息，甚至可以通过受限 API 跟用户生态或者云生态内的其他系统汇报采集到的信息，这可以给数据库系统带来巨大的可观测性提升。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说是一次非常充实的 Hackathon，在一次 Hack 的过程中我们不仅需要跟 TiDB、TiKV 打交道，还了解了各个语言工具链特别是大量 Wasm 周边生态有关的知识，工作量非常的大，感谢队友大腿们 breeswish，Fullstop000 和 Hawkingrei 的带飞。</p><p>在给评委答辩<del>画饼</del>的时候，事实上我也感受到了 Wasm+Wasi 在服务器领域的巨大潜力，如果 Wasm 能在更多系统中大规模落地的话，能在保证数据安全的前提下给用户带来更强更灵活的定制能力。这个 Hackathon 项目也是为这个过程做了一点微小的贡献~</p>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Database</tag>
      
      <tag>TiDB</tag>
      
      <tag>Hackathon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gogo/protobuf 的一个性能 bug</title>
    <link href="/gogo-proto-timestamp/"/>
    <url>/gogo-proto-timestamp/</url>
    
    <content type="html"><![CDATA[<p>源码阅读笔记是不可能续写的，这辈子都不可能续写的，paper notes 也是几年也不会更新一篇的，还不如把博客随便当个笔记本记录点遇到过的有意思的问题好了。</p><p>Protobuf 是 Google 整的一个序列化/反序列化框架，性能不算很好不过用的人比较多，各个语言的实现也比较全，其中 golang 的版本是 google 官方维护的 <a href="https://github.com/golang/protobuf">golang/protobuf</a>，但由于比较保守，对各种新 feature request 不太感兴趣，所以社区广泛使用的是一个 fork 的版本 <a href="https://github.com/gogo/protobuf">gogo/protobuf</a>，gogo 版本不仅在性能上做了很多优化，而且提供了很多 <a href="https://github.com/gogo/protobuf/blob/master/extensions.md">extensions</a>，可以让生成的代码更符合 go 开发的习惯。</p><p>这篇 blog 记录的是在使用 stdtime extension 中遇到的一个性能问题排查过程和修复方案。stdtime extension 可以把 Google 提供的一个公共库中 Timestamp 的类型定义转化为 golang 标准库 <code>time.Time</code> 的定义。</p><a id="more"></a><p>线上开发某个服务的时候用了 gRPC 和 gogo/protobuf，然后其中的 message 定义大概是：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gogo/protobuf/gogoproto/gogo.proto&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/timestamp.proto&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    google.protobuf.Timestamp created_at = <span class="hljs-number">1</span> [(gogoproto.stdtime) = <span class="hljs-literal">true</span>];<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-keyword">repeated</span> A as = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Empty</span> </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">S</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> RPC (Empty) <span class="hljs-keyword">returns</span> (B) </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大概有几千个服务会调这个 RPC，每次返回的 as 的长度大约是 10000 左右。在测试时，从客户端观察，几乎每个请求都要耗时 20 秒以上，但在服务端观察到每个请求的处理时间在 100ms 以下。在排除了网络故障的可能性以后，我开始怀疑是 RPC Framework 的问题。</p><p>Golang 自带的 profile 框架 <code>pprof</code> 是非常好用的，简单跑了个 mutex profile 以后，观察到</p><p><img src="https://i.loli.net/2020/02/05/zsdjBq7XnkapuNH.png" alt="image.png"></p><p>发现阻塞时间基本在 proto 包里的一个 <code>Mutex</code> 上。</p><p>简单翻了一下<a href="https://github.com/golang/protobuf/blob/d23c5127dc24889085f8ccea5c9d560a57a879d8/proto/table_marshal.go#L98-L110">代码</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>marshalInfoMap  = <span class="hljs-keyword">map</span>[reflect.Type]*marshalInfo&#123;&#125;<br>marshalInfoLock sync.Mutex<br>)<br><br><span class="hljs-comment">// getMarshalInfo returns the information to marshal a given type of message.</span><br><span class="hljs-comment">// The info it returns may not necessarily initialized.</span><br><span class="hljs-comment">// t is the type of the message (NOT the pointer to it).</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMarshalInfo</span><span class="hljs-params">(t reflect.Type)</span> *<span class="hljs-title">marshalInfo</span></span> &#123;<br>marshalInfoLock.Lock()<br>u, ok := marshalInfoMap[t]<br><span class="hljs-keyword">if</span> !ok &#123;<br>u = &amp;marshalInfo&#123;typ: t&#125;<br>marshalInfoMap[t] = u<br>&#125;<br>marshalInfoLock.Unlock()<br><span class="hljs-keyword">return</span> u<br>&#125;<br></code></pre></td></tr></table></figure><p>看起来是为了让每个 Message Type 都只会产生一个 <code>*marshalInfo</code>，用了一个全局的 map 和一个全局的 Mutex 来保护。产生大量 message 的时候，这个 Mutex 成为了瓶颈。这段代码在 gogo/protobuf 和 golang/protobuf 同时存在。</p><p>当时觉得已经定位到了问题，并且修复方案也很简单，用 RWMutex 做个 double check 就好了，测试过优化明显后，顺手给 golang/protobuf 交了一个 <a href="https://github.com/golang/protobuf/pull/1004">PR</a>。</p><p>很不幸的是 golang/protobuf 的 maintainer argue 这个函数只会被调用少数次，有几个 message 定义就回被调用几次，与运行时产生的 message 数量无关。并且给出了复现例子，于是只好继续深入定位问题。</p><p>在 demo 中做了若干次详细的试验以后，发现这个 bug 确实只能用 gogo/protobuf 复现，并且必须打开 <code>[(gogoproto.stdtime) = true]</code> 的选项才会产生。</p><p>在打开这个特性开关后，gogo/protobuf 需要引用 google <code>Timestamp</code> 的定义来反序列化数据，再转化为 <code>time.Time</code>，<code>Timestamp</code> 的定义是由 protoc-gen-gogo 生成的，包路径为 <code>github.com/gogo/protobuf/types</code>，然而所有生成的代码都需要反过来依赖 <code>github.com/gogo/protobuf/proto</code>，所以会形成循环依赖。为了解决这个问题，gogo/protobuf 在 <code>github.com/gogo/protobuf/proto</code> 包里 mock 了一个 <a href="https://github.com/gogo/protobuf/blob/5628607bb4c51c3157aacc3a50f0ab707582b805/proto/timestamp_gogo.go#L38-L46">timestamp</a>，只通过 struct tag 定义了最基本的序列化格式，而缺失了一些关键的方法，导致没有满足 <code>newMarshaler</code> 和 <code>Marshaler</code> 的 interface，同时 protobuf 为了满足向后兼容性，入口函数 <a href="https://github.com/gogo/protobuf/blob/5628607bb4c51c3157aacc3a50f0ab707582b805/proto/table_marshal.go#L2936-L2955">Marshal</a> 依然接受不满足 <code>newMarshaler</code>，<code>Marshaler</code> 的参数，只是走了最慢的路径。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Marshal</span><span class="hljs-params">(pb Message)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<br><span class="hljs-keyword">if</span> m, ok := pb.(newMarshaler); ok &#123;<br>siz := m.XXX_Size()<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">0</span>, siz)<br><span class="hljs-keyword">return</span> m.XXX_Marshal(b, <span class="hljs-literal">false</span>)<br>&#125;<br><span class="hljs-keyword">if</span> m, ok := pb.(Marshaler); ok &#123;<br><span class="hljs-comment">// If the message can marshal itself, let it do it, for compatibility.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> This is not efficient.</span><br><span class="hljs-keyword">return</span> m.Marshal()<br>&#125;<br><span class="hljs-comment">// in case somehow we didn&#x27;t generate the wrapper</span><br><span class="hljs-keyword">if</span> pb == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrNil<br>&#125;<br><span class="hljs-keyword">var</span> info InternalMessageInfo<br>siz := info.Size(pb)<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">0</span>, siz)<br><span class="hljs-keyword">return</span> info.Marshal(b, pb, <span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于同时涉及了代码生成和循环依赖问题，这个问题的正确修复方式可能需要涉及到很大的重构，比较简单的 Workaround 有：</p><ul><li>使用 RWMutex 来优化这个全局 map，目前<a href="https://github.com/TennyZhuang/protobuf">我 fork 的版本</a>就是这么干的。</li><li>在 <code>github.com/gogo/protobuf/proto</code> 中依赖 <code>github.com/golang/protobuf/ptypes</code> 中的 <code>Timestamp</code> 来避免循环依赖，但会导致 gogo/protobuf 依赖 golang/protobuf，仍然不是好的解决方案。</li><li>从生成的 <code>github.com/gogo/protobuf/types.Timestamp</code> 中 copy 更多代码到 mock 的 <code>github.com/gogo/protobuf/proto.timestamp</code> 中</li></ul><p>目前提了一个 <a href="https://github.com/gogo/protobuf/issues/656">issue</a>，不过 gogo/protobuf 的维护也不太活跃，在这个 issue 解决之前，建议不使用可能会触发该 bug 的 stdtime，stdduration，customtype 等 extension。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Golang</tag>
      
      <tag>Protobuf</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Paper Notes] Facebook Haystack and F4</title>
    <link href="/haystack-f4/"/>
    <url>/haystack-f4/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf">Haystack</a> 和 <a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-muralidhar.pdf">F4</a> 是 Facebook 为了解决照片存储的场景开发的一套小文件存储系统。整个设计非常简洁（褒义，虽然简洁到让人怀疑这也能发 OSDI），但是却把每个部分的设计和考虑解释得非常清楚。读完 <a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf">GFS</a> 会感觉有不少未解之谜在 paper 中没交代清楚，但读完 Haystack 和 F4 就感觉异常通顺。Facebook 一开始开发了 Haystack 是为了覆盖整个照片存储场景，后来发现了温存储场景可以优化的地方，又开发了 F4 将冷数据从 Haystack 中剥离出来，单独存储，并且 F4 的 paper 中描述了整套 BLOB Storage 系统同时修改了一些 Haystack 的设定，因此将这两篇放在一起讲。F4 也分享了很多 Facebook 在这套系统的设计和使用上的很多经验，值得学习。</p><a id="more"></a><h2 id="Haystack"><a href="#Haystack" class="headerlink" title="Haystack"></a>Haystack</h2><blockquote><p>Needle in a haystack</p></blockquote><p>Needle 是 Haystack 中的基本存储单位，英文翻译是针，Haystack 的英文翻译是草垛。出于好奇 Facebook 为什么取了这个名字的目的去搜了一下，发现这是一句类似于“大海捞针”（草垛里捞针）的常用短语，这么理解的话这个名字对于一个存储海量小文件的存储系统就非常形象了~</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>在开发 Haystack 之前，Facebook 使用基于 NFS 的设计方案。每个小文件直接对应 NFS 上的一个物理文件，在 CDN Cache Miss 的文件会直接通过 Photo Server 落到 NFS 上读，这种方案的缺陷非常明显，就是小文件给文件系统带来的太多元数据。POSIX 文件系统在文件节点上存储了大量 Facebook 的场景下不需要的信息（如权限信息等），每个 INode 都要占据大约 500 byte 的空间，导致在大量小文件的场景下，文件系统无法将元信息全部缓存到自己的内存中，访问数据的时候，除了必须要的一次数据读取的磁盘 IO，在获取元数据以定位真实数据位置的过程中也需要经过若干次磁盘 IO，这是基于 NFS 的系统导致图片访问慢的主要原因。</p><p>Haystack 的优化目标非常明确，就是砍掉无用的元信息，压缩元信息到足够小并全部加载到内存中，将对单张图片的访问精确地缩减为一次磁盘 IO。</p><p>Haystack 的优化思路也非常的简单，既然小文件的元信息太多，那么就把大量小文件打包成大文件再存，自己维护小文件需要的少量 元信息。在 Haystack 中，存储的小文件及其元信息称为 Needle，而打成的大文件包称为 Volume。Haystack 的核心部分其实就是这个单机的小文件存储引擎。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://i.loli.net/2019/03/24/5c975a4eb47ba.png" alt="Figure 3 in Haystack"></p><h4 id="Haystack-Cache"><a href="#Haystack-Cache" class="headerlink" title="Haystack Cache"></a>Haystack Cache</h4><p>Facebook 的架构里用户除了访问 CDN 以外，也可以跳过 CDN 直接访问数据，这两种请求最终都会由 Haystack Cache 处理（猜测区别仅仅是内部和外部 Cache）。Haystack Cache 就是个很平凡的 Cache 逻辑，以 Photo ID 为 key 维护了一个分布式哈希表，如果请求的照片没有缓存，就从底层的 Haystack Store 读取数据，并且对<strong>满足一定条件的</strong>查询结果进行缓存。</p><p>这块唯一需要注意一些的就是这个缓存条件，当且仅当满足两个条件的时候，Haystack Cache 才会进行缓存：</p><ol><li>直接来自用户，而非来自 CDN 的请求。对于一般的来自 CDN 的请求，Haystack 直接将缓存的任务交给对方。从这个角度来看，Haystack Cache 的定位基本就等于一个系统内部的 CDN。</li><li>照片存在 write-enabled 节点上的。这个跟之后提到的照片热度的 Timezone 有关，可以简单理解为从 Facebook 的场景来看，上传了很长一段时间以后的照片没有缓存价值。</li></ol><h4 id="Haystack-Store"><a href="#Haystack-Store" class="headerlink" title="Haystack Store"></a>Haystack Store</h4><p>Haystack Store 是最核心的模块，也就是 Haystack 的存储节点。Haystack 放弃了原生的 POSIX 作为小文件存储的接口，但沿用了 POSIX 文件系统的底层，自己基于这个底层开发了一个单机的小文件存储系统，并运行在每块 Disk 或者每个节点上、</p><p>每个 Volume 有唯一的 Volume ID，标识一个 Logical Volume，但为了数据可靠性，每个 Logical Volume 在集群内会有三个副本，这些 Volume 实体称为 Physical Volume，在单机的存储引擎中。这些 Physical Volume 是真实的 POSIX 文件系统下的文件单位，分散在 Haystack Store 的节点中。</p><p>每个 Volume 会存储数百万张照片，并由三个文件组成，Data file 和 Index file 和 Journal file（后续加入）。Data file 由连续的 Needle 组成，每个 Needle 除了存储图片本身的数据以外，还存储了一些额外的元信息，其中比较 重要的有照片的 key 和 alternate key，图片的 size 和 checksum，以及一个删除标志位。</p><p>key 和 alternate key 用于 Facebook 场景下的二层索引，因为 Facebook 对每张照片存了四种不同 size 的图片（包括缩略图，小图，大图，原图），因此每张照片有一个主键，然后再通过 alternate key 对应到需要的尺寸的图片。</p><p>根据 key 和 alternate key，Haystack store 的每个节点在内存中为每个 volume 构建了一个双层的索引，用于快速找到对应的 Needle 在 data file 中的偏移量，并缓存了 size 信息减少一次读取元信息的 IO。而 Index file 是这个索引文件的一个快照。</p><p>一个 Volume 支持数据粒度的 Read，Write 和 Delete 操作，实现在了解数据的定义之后都非常的 trivial，直接通过下面的伪代码展示，但有一些场景需要考虑。</p><p>Index file 是定期 dump 到磁盘中的，因此宕机时会丢失数据，需要恢复，对于新写入的数据这非常简单，因为遗失的数据总是在 data file 的尾部，从 index 中最高的 offset 开始从 data file 恢复这些 meta 信息即可。但是对于删除的数据无法简单地恢复，在旧版本的 Haystack（即 Haystack paper）中，删除是通过修改 data file 中 needle 的标志位来完成持久化的，而在新版本（F4 paper 中提到的 Haystack），每次删除文件仅需要在 journal file 中添加一条记录，这是磁盘 append 操作因此非常快，而 Index 在宕机恢复时仅需要将 Journal file 和 Index file 做一个 merge 即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Needle <span class="hljs-keyword">struct</span> &#123;<br>    header       [<span class="hljs-number">4</span>]<span class="hljs-keyword">byte</span> <span class="hljs-comment">// 标识 Needle 开头，恢复数据的时候比较有用</span><br>    cookie       <span class="hljs-keyword">uint64</span>  <span class="hljs-comment">// 我也不知道是干嘛的，据说是反爬虫用的</span><br>    key          <span class="hljs-keyword">uint64</span>  <br>    alternateKey <span class="hljs-keyword">uint64</span>  <br>    flags        <span class="hljs-keyword">uint8</span>   <span class="hljs-comment">// 目前看起来只标志 deleted，并且在后续不再需要这个 deleted flag</span><br>    size         <span class="hljs-keyword">uint16</span><br>    data         []<span class="hljs-keyword">byte</span><br>    footer       [<span class="hljs-number">4</span>]<span class="hljs-keyword">byte</span> <span class="hljs-comment">// 标识 needle 结尾，恢复数据的时候比较有用</span><br>    checksum     <span class="hljs-keyword">uint32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> needleMeta <span class="hljs-keyword">struct</span> &#123;<br>    offset <span class="hljs-keyword">uint64</span><br>    size   <span class="hljs-keyword">uint16</span><br>&#125;<br><br><span class="hljs-keyword">type</span> indexItem <span class="hljs-keyword">struct</span> &#123;<br>    needleMeta<br>    key          <span class="hljs-keyword">uint64</span><br>    alternateKey <span class="hljs-keyword">uint32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Volume <span class="hljs-keyword">struct</span> &#123;<br>    index        <span class="hljs-keyword">map</span>[<span class="hljs-keyword">uint64</span>]<span class="hljs-keyword">map</span>[<span class="hljs-keyword">uint32</span>]*needleMeta<br>    dataFile     *os.File<br>    journalFile  *os.File<br>    indexFile    *os.File<br>    indexCache   []indexItem<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Volume)</span> <span class="hljs-title">dump</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 定期执行</span><br>    v.indexFile.Write(binary.Encode(v.indexCache))<br>    v.indexCache = <span class="hljs-built_in">make</span>([]indexItem, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Volume)</span> <span class="hljs-title">Recover</span><span class="hljs-params">()</span></span> &#123;<br>    v.indexFile.Seek(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">var</span> it *indexItem<br>    <span class="hljs-keyword">for</span> &#123;<br>        *it, err = Read(v.indexFile, sizeof(indexItem)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">break</span> &#125;<br>        v.index[it.key][it.alternateKey] = v.needleMeta<br>    &#125;<br>    <span class="hljs-keyword">var</span> offset <span class="hljs-keyword">uint64</span><br>    <span class="hljs-keyword">if</span> it == <span class="hljs-literal">nil</span> &#123; offset = <span class="hljs-number">0</span> &#125; <span class="hljs-keyword">else</span> &#123; offset = it.offset &#125;<br>    v.dataFile.Seek(offset)<br>    <span class="hljs-keyword">for</span> &#123;<br>        needle, offset, err := Read(v.dataFile, sizeof(needle))<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">break</span> &#125;<br>        it := indexItem&#123;offset, needle.size, needle.key, needle.alternateKey&#125;<br>        v.indexCache = <span class="hljs-built_in">append</span>(v.indexCache, it)<br>        index[it.key][it.alternateKey] = it.needleMeta<br>    &#125;<br>    v.jornalFile.Seek(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        key, alternateKey, offset, err := Read(v.jornalFile, <span class="hljs-number">64</span>+<span class="hljs-number">32</span>+<span class="hljs-number">64</span>)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">break</span> &#125;<br>        meta, ok := v.index[key][alternateKey]<br>        <span class="hljs-keyword">if</span> ok &amp;&amp; meta.offset &lt;= offset &#123;<br>            <span class="hljs-built_in">delete</span>(v.index[key], alternateKey)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Volume)</span> <span class="hljs-title">Read</span><span class="hljs-params">(key <span class="hljs-keyword">uint64</span>, alternateKey <span class="hljs-keyword">uint32</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<br>    meta, ok := v.index[key][alternateKey]<br>    <span class="hljs-keyword">if</span> !ok &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errNotFound &#125;<br><br>    <span class="hljs-keyword">return</span> Pread(v.dataFile, meta.offset, meta.size)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Volume)</span> <span class="hljs-title">Write</span><span class="hljs-params">(key <span class="hljs-keyword">uint64</span>, alternateKey <span class="hljs-keyword">uint32</span>, data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>    n := Needle &#123;<br>        header:       [<span class="hljs-number">4</span>]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;NEED&quot;</span>),<br>        cookie:       rand.Uint64(),<br>        key:          key,<br>        alternateKey: alternateKey,<br>        flags:        <span class="hljs-number">0</span>,<br>        size:         <span class="hljs-built_in">len</span>(data),<br>        data:         data,<br>        footer:       [<span class="hljs-number">4</span>]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;DEEN&quot;</span>),<br>        checksum:     crc32(data),<br>    &#125;<br>    offset, err := v.dataFile.Write(binary.Encode(&amp;n))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> err &#125;<br>    v.index[key][alternateKey] = &amp;needleMeta&#123;<br>        offset: offset,<br>        size:   <span class="hljs-built_in">len</span>(data),<br>        flags:  <span class="hljs-number">0</span>,<br>    &#125;<br>    v.indexCache = <span class="hljs-built_in">append</span>(v.indexCache, indexItem&#123;...&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Volume)</span> <span class="hljs-title">Delete</span><span class="hljs-params">(key <span class="hljs-keyword">uint64</span>, alternateKey <span class="hljs-keyword">uint32</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>    meta, ok := v.index[key][alternateKey]<br>    <span class="hljs-keyword">if</span> !ok &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    <span class="hljs-built_in">delete</span>(v.index[key], alternateKey)<br>    <span class="hljs-comment">// 这里需要持久化记录 offset，避免恢复 index file 的时候将删除操作之后新添加的同一个 key 的数据也删除</span><br>    <span class="hljs-keyword">return</span> v.journalFile.Write(binary.Encode(key, alternateKey, meta.offset))<br>&#125;<br></code></pre></td></tr></table></figure><p>为了避免垃圾数据过多，volume 还会根据一定条件触发 Compaction，回收已经被 Delete 或者被 Write 覆盖的数据。</p><p>除了单个 volume，我们考虑一下如何在多个 Physical volume 之间保持一致性，Haystack 的答案似乎就是根本不管。由于 Write 和 Delete 非常幂等，并且 Photo Store 稍微不一致也不是特别要紧，Haystack 选择添加监控并且手动处理一些不一致的异常情况。</p><h4 id="Haystack-Directory"><a href="#Haystack-Directory" class="headerlink" title="Haystack Directory"></a>Haystack Directory</h4><p>这是个 paper 笔墨很少，但十分重要的组件，它存储了所有的元信息，比如 volume ID 到 physical volume 位置的映射。它负责调度用户的请求，包括负载均衡写请求的 logical volume，负载均衡读请求打到哪个 physical volume 等的调度。为了避免一个 volume 无限增长造成运维困难，directory 会在 volume 大小达到一定容量时将 volume 标记为 read-only。</p><h4 id="Pitchfork"><a href="#Pitchfork" class="headerlink" title="Pitchfork"></a>Pitchfork</h4><p>这个就是个健康检测后台任务，定期给所有存储节点发请求，观测到一个 volume 发生异常时标记为 read-only 并找运维人肉处理。这不会影响服务的整体可用性，因为写请求可以打到任意一个 volume。</p><h2 id="F4"><a href="#F4" class="headerlink" title="F4"></a>F4</h2><p>F4 是 Facebook 在 Haystack 之后又搞的一个 Warm blob store，这个 warm 就比较魔性，让人想起星巴克的中杯、大杯和超大杯。不过事实上，F4 存储的确实不是冷存储，而是 Facebook 的一些 long tail 的照片，他们仍然会被获取，但是频率较低，也很少被覆盖或删除。相比于一些获取数据需要以天为单位的真正的 cold storage，F4 仍然要求对数据的获取在百毫秒级的时间内完成响应。</p><h3 id="F4-和-Haystack-的关系"><a href="#F4-和-Haystack-的关系" class="headerlink" title="F4 和 Haystack 的关系"></a>F4 和 Haystack 的关系</h3><p>在 Haystack 中的数据因为三副本的原因有比较高的存储成本，F4 的设计目标主要是在保证数据安全的情况下降低数据的存储成本。一点可以利用的性质是从 Haystack 导入 F4 的照片很少会被删除，我们可以认为整个 Volume 都是不可变数据。</p><p>Haystack 和 F4 的接口完全保证一致，通过 router tier 对用户隐藏具体实现。</p><p>在数据导入的时间点上，Haystack 基于底层硬件设备（HDD）的读写能力和 BLOB 的使用情况统计进行设计，以 80 IOPS/TB 作为分界线对统计结果进行划分，并确定了三个月的分界线，即对于 Facebook 的大部分 BLOB 数据来说，在经过三个月的时间以后，访问频率就会降到显著低于 80 IOPS/TB，以至于使用廉价的 HDD 作为存储介质依然可以提供不影响用户体验的服务。这个设计过程也是充分地利用了软硬件一体的设计思想。</p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>为了减少空间的使用，F4 引入了 EC（erasure coding）的技术。n:m 的 EC 可以将一份数据切为 n 份，并且构造 m 个冗余块。在这 (n+m) 个块中任意丢失 m 块数据，都能通过剩下 n 个块恢复。因此保障数据安全仅需要 (n+m)/n 的空间。Facebook 选择了 10:4 的比例，比起三副本来说，可以节约大量的空间。为了异地灾备，Facebook 在两个不同的集群之间再次通过对两个 Volume XOR 编码，并将这份冗余块备份到第三个集群中，通过 1.4 * 1.5 = 2.1 倍的空间完成了异地灾备级别的数据可靠性。</p><p>在 F4 中，一个从 Haystack 导入的 Volume 前会经过 compaction。在 F4 中，Volume 里较小的 index file 仍然通过三副本，但是占 Volume 主体的 data file 完全通过 EC 来保障数据的可靠性和可用性。每个 data file 会按固定的大小（1GB 左右）切成连续的 data block，然后为每 n 个 data block（称为 strip），生成 m 个 parity block，不足 n 个的部分填零补全。每个 Strip 对应的 n+m 个 block 会被分布在不同的机架中，来保证机架级别的容错域。</p><h3 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h3><p>架构上分为了五种类型的节点，并将这些节点打包成了一个 F4 Cell。</p><p><img src="https://i.loli.net/2019/03/30/5c9f31fcbea4f.png" alt="F4 Figure 8"></p><ol><li>Name Node：管理了 Volume -&gt; Strip -&gt; Block 的 Mapping 关系的 NameNode，这个功能非常简单直接忽略其实现。</li><li>Storage Node：Storage Heavy 的节点，应该配有大量的 HDD，存储 Block，并管理对 Block 的读取操作。</li><li>Backoff Node：CPU Heavy 的节点，在部分 data blocks 损坏时，在 parity blocks 继续读取数据对外提供服务保证可用性。</li><li>Rebuilder Node：在有 data block 或者 parity block 损坏时，负责恢复数据。由于 F4 paper 中没有提到 Volume 如何从 Haystack 中入库到 F4 中，猜测初始化 parity block 这部分也是由 Rebuilder Node 负责。</li><li>Coordinator Node：一个 Cell 的任务调度节点。进行一些定期检查，容错域调度等维护任务的调度。</li></ol><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>虽然 F4 不支持修改数据，但为了用户数据的隐私，允许对数据进行删除。</p><p>在最开始的设计中，F4 的开发者计划在 F4 中保留 Haystack 中的 Jornal file 作为文件的删除记录，并保留 compaction 的策略。很快他们发现在 F4 设计中留这个可变的因素会大大增加设计复杂度。因此 F4 换了个删除的思路，将所有 BLOB 在导入 F4 前用每个 BLOB 唯一的秘钥加密，并将秘钥存在外部数据库中，如果需要删除数据，只需要在外部数据库中删除这个秘钥，就能让加密的 BLOB 无法通过任何手段恢复原来的数据，从逻辑上做到了 BLOB 的删除。</p><h4 id="effective-replication-factor"><a href="#effective-replication-factor" class="headerlink" title="effective-replication-factor"></a>effective-replication-factor</h4><p>这个词翻不太来，大约是指备份的数据相比原始数据的比例。在 Haystack 中这个数字是 3.6，由三备份和 1.2 倍的 RAID 组成，在 F4 中，这个数字被降低到了 2.1。不过这个可以节约空间的前提是建立在 F4 中的数据删除比例比较少，根据 Facebook 的统计结果，对于大于三个月的 BLOB，这个结论成立。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Paper Note</tag>
      
      <tag>Storage</tag>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPython 源码（一）： PyObject</title>
    <link href="/pyobject/"/>
    <url>/pyobject/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是 CPython 源码阅读系列的第一篇，我也不知道能坚持多久，或许连这篇都写不完（如果你能在网上看到这句话，说明至少第一篇写完了）。</p><p>Python 是一门非常强大的动态语言，语法特性多且优美，非常符合人类直觉，是我最喜欢的语言之一，再加上 CPython 做的优化非常少（笑），不像某些 JS 引擎如 V8，为了性能各种 hack 技巧太多不适合阅读学习。</p><p><a href="https://github.com/python/cpython">CPython 源码链接</a></p><p>对 Python 比较精通以后，自然而然会产生疑问，那么强大的 Python，是怎么通过一门语法特性非常少的静态语言 C 来实现的呢？</p><p><del>当然，阅读 CPython 源码的第一步，就是让你抛弃 C 语言是静态类型的错觉。</del></p><p>本系列无明显顺序，更类似于个人阅读中的笔记，可能有错误，欢迎指出。</p><p>本系列文章要求阅读者：</p><ul><li>了解 C 语言的特性，特别是强制转换时的行为</li><li>了解 Python 语言本身的基本行为和高级特性</li></ul><a id="more"></a><p>作者开始阅读源码时，使用的 Python 版本是 <code>Python 3.7.0a0</code>，最新的 commit 号为 <code>984eef7d6d78e1213d6ea99897343a5059a07c59</code>。</p><p>本文涉及的核心文件是</p><ul><li><a href="https://github.com/python/cpython/blob/master/Include/object.h">Include/object.h</a></li><li><a href="https://github.com/python/cpython/blob/master/Objects/object.c">Objects/object.c</a></li></ul><h2 id="PyObject"><a href="#PyObject" class="headerlink" title="PyObject"></a>PyObject</h2><p>一切都要从 Hello World 开始，CPython 源码阅读的 Hello World，当然是从 <code>PyObject</code> 开始。</p><p>首先，在 <code>object.h</code> 里找到 <code>PyObject</code> 的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">object</span> &#123;</span><br>    _PyObject_HEAD_EXTRA<br>    Py_ssize_t ob_refcnt;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">typeobject</span> *<span class="hljs-title">ob_type</span>;</span><br>&#125; PyObject;<br></code></pre></td></tr></table></figure><p>Python 中的一切对象，都至少保存了以上属性，这也是为什么在 Python 中，哪怕是一个简单的 <code>0</code>，也比 C 语言占用了更多内存的原因。</p><p><code>_PyObject_HEAD_EXTRA</code> 这个宏是全空的，应该是为了未来可能的修改而保留修改空间，可以先忽略它。</p><p>观察一下 <code>ob_refcnt</code> 和 <code>ob_type</code>。</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>Python 是一门自带 GC 的语言，而 Python 的 GC 是以引用计数机制为主的，<code>ob_refcnt</code> 保存了 Python 每个对象被引用的次数。</p><p>在 <code>object.c</code> 中实现了一个函数 <code>Py_IncRef</code>，这个是暴露给 Python runtime embedders 的管理 <code>PyObject</code> 引用计数的接口，而源码内部的实现基本调用的是 <code>Py_XINCREF</code>（附录 0） 和 <code>Py_INCREF</code> 这两个宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Macros to use in case the object pointer may be NULL: */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Py_XINCREF(op)                                \</span><br><span class="hljs-meta">    do &#123;                                              \</span><br><span class="hljs-meta">        PyObject *_py_xincref_tmp = (PyObject *)(op); \</span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">if</span> (_py_xincref_tmp != NULL)                  \</span><br><span class="hljs-meta">            Py_INCREF(_py_xincref_tmp);               \</span><br><span class="hljs-meta">    &#125; while (0)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Py_INCREF(op) (                         \</span><br><span class="hljs-meta">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span><br><span class="hljs-meta">    ((PyObject *)(op))-&gt;ob_refcnt++)</span><br></code></pre></td></tr></table></figure><p>我们先假装没看到一系列的强制转换，那么这两个宏的作用就分别是 safe 和 unsafe 地增加一个 PyObject 的引用计数。</p><p>关于 <code>ob_refcount</code> 还定义了一些别的宏，具体的运用方式想放在 GC 的章节一起看。</p><p><code>ob_refcount</code> 的类型是 <code>Py_ssize_t</code>，这个类型在我的系统上等价于 <code>long</code>，再加上为了为了效率，维护引用计数的时候显然不会作边界检查，这就意味着如果你的一个对象引用超过 <code>LONG_MAX</code> 的话应该会溢出，然而虽然很想尝试一下，但我并不知道怎么在爆 Memory Overflow 前让一个对象的引用计数超过 <code>long</code>。</p><h2 id="PyVarObject"><a href="#PyVarObject" class="headerlink" title="PyVarObject"></a>PyVarObject</h2><p><code>ob_type</code> 显然保存着对象的类型信息，然而在观察其具体实现之前，我们可以看一下紧跟着 <code>PyObject</code> 的另一个结构体的定义，<code>PyVarObject</code>。</p><p>根据注释，<code>PyVarObject</code> 用来存储变长的 python 对象（如 list 等），熟悉 C++ 的同学可能已经忍不住脑补出以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// fake PyVarObject</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PyVarObject</span> :</span> <span class="hljs-keyword">public</span> PyObject &#123;<br><span class="hljs-keyword">public</span>:<br>    Py_ssize_t ob_size;<br>&#125;;<br></code></pre></td></tr></table></figure><p>那我们再来看它在 CPython 中的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    PyObject ob_base;<br>    Py_ssize_t ob_size; <span class="hljs-comment">/* Number of items in variable part */</span><br>&#125; PyVarObject;<br></code></pre></td></tr></table></figure><p>看起来非常反人类的做法，难道每次想操作 PyVarObject 中 <code>ob_type</code> 的时候都要多一层 <code>ob_base</code> 吗？</p><p>然后就是一个比较神奇的操作，而且唯有 C 这种结构体严格映射内存结构的语言才能做到（附录 1），对于 C 来说，<code>PyObject ob_base;</code> 的内存结构和 <code>_PyObject_HEAD_EXTRA Py_ssize_t ob_refcnt; struct _typeobject *ob_type;</code> 是完全等价的，那么可以直接把 <code>PyVarObject*</code> 类型的对象强制转换成 <code>PyObject*</code> 类型的对象，然后直接当成 PyObject* 类型操作。</p><p><img src="https://i.loli.net/2017/07/30/597dff20cbd40.png" alt="内存结构图"></p><p>现在我们可以回过去看代码中对于 <code>PyObject</code> 某段注释：</p><blockquote><p>Nothing is actually declared to be a PyObject, but every pointer to<br>a Python object can be cast to a PyObject<em>.  This is inheritance built<br>by hand.  Similarly every pointer to a variable-size Python object can,<br>in addition, be cast to PyVarObject</em>.</p></blockquote><p><code>PyObject</code> 不是 Python 中的任何一种类型，但是任何任何 Python 对象的指针都能被 cast 成 <code>PyObject*</code>，相当于手动实现了继承（附录 2）。同理如 <code>PyVarObject*</code>。</p><p>为了方便之后 Python 中对象的定义，object.h 中定义了两个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PyObject_HEAD                   PyObject ob_base;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PyObject_VAR_HEAD      PyVarObject ob_base;</span><br></code></pre></td></tr></table></figure><p>利用这两个宏来达到继承 <code>PyObject</code> 和 <code>PyVarObject</code> 的作用。</p><p>（看到这里，你可以再思考一下 C 究竟是不是静态语言，至少有没有被人当静态语言用）</p><p>为了获取 <code>PyObject</code> 和 <code>PyVarObject</code> 中的基础变量，<code>object.h</code> 定义了三个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Py_REFCNT(ob)           (((PyObject*)(ob))-&gt;ob_refcnt)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Py_TYPE(ob)             (((PyObject*)(ob))-&gt;ob_type)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Py_SIZE(ob)             (((PyVarObject*)(ob))-&gt;ob_size)</span><br></code></pre></td></tr></table></figure><p>任何 Python 中的对象都能通过这些宏来获取对应的信息来进行读写。</p><h2 id="PyTypeObject"><a href="#PyTypeObject" class="headerlink" title="PyTypeObject"></a>PyTypeObject</h2><p>Python 中一切皆为对象，类型也不例外。</p><p>现在让我们回到被我们跳过的 <code>ob_type</code>，这是一个指向 <code>PyTypeObject</code> 对象的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">typeobject</span> &#123;</span><br>    PyObject_VAR_HEAD<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *tp_name; <span class="hljs-comment">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span><br>    Py_ssize_t tp_basicsize, tp_itemsize; <span class="hljs-comment">/* For allocation */</span><br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>PyTypeObject</code> 继承了 <code>PyVarObject</code>，这个对象非常的复杂，在之后的文章再详细介绍。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>[0]: 关于 <code>do ... while(0)</code> 的<a href="http://www.bruceblinn.com/linuxinfo/DoWhile.html">解释</a>，之后的贴代码的时候可能会省略该部分。</p><p>[1]: 参见 <a href="https://stackoverflow.com/questions/2748995/c-struct-memory-layout">https://stackoverflow.com/questions/2748995/c-struct-memory-layout</a></p><p>[2]: 虽然 C 语言里没有继承的语法，不过这个概念完全是继承，再加上作者钦定了，所以之后将直接用「继承了 <code>PyObject</code>」 这种语言来描述这种行为。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Source Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HaScheme</title>
    <link href="/HaScheme/"/>
    <url>/HaScheme/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/TennyZhuang/HaScheme">HaScheme</a> 是用 Haskell 实现的 Scheme 解释器，作为 函数式编程语言课程的 Course Project, 应该是这学期最满意且收获最多的一个大作业了，得益于之前编译原理 Course Project <a href="https://github.com/TennyZhuang/NaiveC">NaiveC</a> 踩了很多坑，对编译器/解释器前端相关的一些理论有了一些了解，在连肝五天以后基本完成了 Scheme 标准语法的大部分内容。</p><p>HaScheme 基于 Stack 构建了项目，如经典的解释器架构一样，将项目主要划分为了三个模块，<code>Lexer</code>，<code>Parser</code> 和 <code>Interpreter</code>，输入的 Scheme 代码首先通过 Lexer 转为 token 序列，然后通过 Parser 将 tokens 转换为 AST，最后由 Interpreter 解释 AST 执行。</p><p>HaScheme 参考了很多 <a href="https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">Write yourself a Scheme in 48 hours</a> 这个教程的内容，这个教程非常初学者友好，不过这个教程实现的文法作用域有一些 bug。HaScheme 中修复了文法作用域的问题，并且扩展了语法特性。</p><a id="more"></a><h2 id="Lexer-and-Parser"><a href="#Lexer-and-Parser" class="headerlink" title="Lexer and Parser"></a>Lexer and Parser</h2><p>Lexer 和 Parser 是写的最舒服的一部分了，主要是 ParseC 实在太好用了，可以用原生 Haskell 代码直接描绘语法生成式的结构，并通过 Parser Monad 很轻松的转换为想要的数据结构。</p><p>ParseC 是自顶向下分析的，遇到不匹配的情况需要用 <code>try</code> 回溯，比较遗憾的是对于需要回溯的情况，ParseC 无法正确地输出报错信息，对于这部分我也没有特别处理，所以 Parser 的报错系统非常简陋。</p><h2 id="文法作用域的实现"><a href="#文法作用域的实现" class="headerlink" title="文法作用域的实现"></a>文法作用域的实现</h2><p>Haskell 原生的数据结构就是 AST 的形式，配合 Pattern Match 解释起来简直爽到起飞，不过 Immutable 的特性就不那么令人愉快了，应该是我姿势水平不足的缘故，不少操作（如 <code>define</code>，<code>set!</code>）在解释的过程中是会对环境造成影响的，一开始我尝试用 State Monad 来实现环境，大概思路是</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-keyword">import</span> Control.Monad.State<br><br><span class="hljs-title">schemeDefineVar</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">SchemeValue</span> -&gt; <span class="hljs-type">State</span> <span class="hljs-type">Environment</span> ()<br></code></pre></td></tr></table></figure><p>不过这样的话，非常困扰于文法作用域的实现，因为对于一个作用域，必须能引用父级作用域的中的变量，也可以支持 Variable Shadowing 而不对父级作用域造成影响。</p><p>最终的实现参考了教程，即基于 <code>Data.IORef</code> 来实现变量。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-keyword">import</span> Data.Map<br><span class="hljs-keyword">import</span> Data.IORef<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Environment</span> = <span class="hljs-type">IORef</span> (<span class="hljs-type">Map</span> <span class="hljs-type">String</span> (<span class="hljs-type">IORef</span> <span class="hljs-type">SchemeValue</span>))</span><br></code></pre></td></tr></table></figure><p>等于在命令式语言中保存了变量实体的指针，这样在新建一个子级作用域的时候，可以简单的拷贝当前环境，子级作用域也能对当前环境的变量进行读写，同时在新增变量时只对新的环境进行修改而不影响父级作用域的环境。</p><p>这部分就是<a href="https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Adding_Variables_and_Assignment">教程</a>实现错误的地方，教程中，对于 <code>define</code> 一个同名变量</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">defineVar</span> :: <span class="hljs-type">Env</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">LispVal</span> -&gt; <span class="hljs-type">IOThrowsError</span> <span class="hljs-type">LispVal</span><br><span class="hljs-title">defineVar</span> envRef var value = <span class="hljs-keyword">do</span><br>     alreadyDefined &lt;- liftIO $ isBound envRef var<br>     <span class="hljs-keyword">if</span> alreadyDefined<br>        <span class="hljs-keyword">then</span> setVar envRef var value &gt;&gt; return value<br>        <span class="hljs-keyword">else</span> liftIO $ <span class="hljs-keyword">do</span><br>             valueRef &lt;- newIORef value<br>             env &lt;- readIORef envRef<br>             writeIORef envRef ((var, valueRef) : env)<br>             return value<br></code></pre></td></tr></table></figure><p>他会简单的修改修改变量的值为新的值，这回导致对父级作用域的变量进行修改，而这时候正确的行为是掩蔽父级作用域的同名变量，即新建一个 <code>IORef</code> 替换当前的 <code>IORef</code> 而非修改当前的 IORef。</p><p>教程中的实现会产生如下 bug</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">f</span> x y)<br>  (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> ((<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x)<br>    (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> x <span class="hljs-number">1</span>)) y) x)<br><br>(<span class="hljs-name">f</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>正确的输出应该是 7，然而执行的结果却是 9，因为嵌套内部的函数参数 x 修改了外部 x 的值。</p><p>在我的实现中</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">defineVar</span> :: <span class="hljs-type">Environment</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">SchemeValue</span> -&gt; <span class="hljs-type">IOThrowsError</span> <span class="hljs-type">SchemeValue</span><br><span class="hljs-title">defineVar</span> envRef varname val = <span class="hljs-keyword">do</span><br>  env &lt;- liftIO $ readIORef envRef<br>  liftIO $ <span class="hljs-keyword">do</span><br>    valRef &lt;- newIORef val<br>    writeIORef envRef (<span class="hljs-type">Map</span>.insert varname valRef env)<br>    return val<br></code></pre></td></tr></table></figure><p>删去了变量是否存在的判断，一律插入新的 <code>IORef</code>，修复了这个 bug。</p><h2 id="命令式语言特性的实现"><a href="#命令式语言特性的实现" class="headerlink" title="命令式语言特性的实现"></a>命令式语言特性的实现</h2><p>Haskell 是支持一部分命令式的语法的，所以我实现了 <code>begin</code> 语句 和 <code>while</code> 语句，不过在我的实现方法中很难正确的实现 <code>while</code> 语句，所以我用了一个很 Hack 的实现，在 Parser 的阶段将 <code>while</code> 语句 parse 成 <code>if</code> 语句和 尾递归调用的语法糖，这种实现有很多问题比如栈溢出等，所以其实没有正确实现这个特性。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">parseWhile</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Expr</span><br><span class="hljs-title">parseWhile</span> = <span class="hljs-keyword">do</span><br>  char &#x27;(&#x27;<br>  reserved <span class="hljs-string">&quot;while&quot;</span><br>  spaces<br>  cond &lt;- parseExpr<br>  spaces<br>  body &lt;- parseExpr<br>  char &#x27;)&#x27;<br>  return . <span class="hljs-type">BeginExpr</span> $ <span class="hljs-type">ListExpr</span> [<br>    <span class="hljs-type">DefineVarExpr</span> <span class="hljs-string">&quot;`whilerec&quot;</span> (<br>      <span class="hljs-type">LambdaFuncExpr</span> [] (<br>        <span class="hljs-type">IfExpr</span> cond (<span class="hljs-type">BeginExpr</span> $ <span class="hljs-type">ListExpr</span> [<br>          body,<br>          <span class="hljs-type">FuncCallExpr</span> (<span class="hljs-type">SymbolExpr</span> <span class="hljs-string">&quot;`whilerec&quot;</span>) (<span class="hljs-type">ListExpr</span> [])<br>        ]) cond)<br>    ),<br>    <span class="hljs-type">FuncCallExpr</span> (<span class="hljs-type">SymbolExpr</span> <span class="hljs-string">&quot;`whilerec&quot;</span>) (<span class="hljs-type">ListExpr</span> [])]<br></code></pre></td></tr></table></figure><h2 id="REPL"><a href="#REPL" class="headerlink" title="REPL"></a>REPL</h2><p>没有 REPL 的解释器是不完整的，这里非常感谢 <a href="http://hackage.haskell.org/package/haskeline">Haskeline</a> 的作者，借助 Haskeline 强大的 API，实现了很好用的 REPL。</p><p><img src="http://7xleha.com1.z0.glb.clouddn.com/repl.gif" alt="repl"></p><p>实现了历史记录、自动补全、语法树查看等特性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2016 软工个人总结 与 CamusAPI</title>
    <link href="/se2016/"/>
    <url>/se2016/</url>
    
    <content type="html"><![CDATA[<p>这学期（又）上了一遍软工3，一开始准备做个微信端的校园服务公众号，后来感觉不是很喜欢微信开发，需要纠结很多微信 API 和权限的问题，所以更换了纯 API 的项目。</p><p><a href="https://github.com/TennyZhuang/CamusAPI">CamusAPI</a> 这个项目的初衷是希望建立一个清华内部的校园开放 API 平台，供校园应用的开发者使用，不需要处理复杂的爬虫逻辑和页面逻辑，将学校的系统封装成一层清晰完整的 RESTful API 系统。</p><a id="more"></a><p>由于本来就有比较丰富的开发经验，知道架构对整个项目的重要性，所以一开始的项目架构是我独立完成的，将项目根据功能划分成了好几个模块，尽可能地减少模块间的耦合。此外，考虑到去年开发紫荆之声时代码风格的丑陋和整个团队开发风格的不一致，我又提前配置了 <a href="http://eslint.org/">ESLint</a> 和 <a href="http://travis-ci.com/">travis-ci</a>，确保整个团队的代码风格完全统一且严谨，对诸如每个函数的行数，每个文件的行数，最大缩进层数也做出了严格的限制，不通过 ESLint 的 commit 不会被合并到主分支，虽然这会增加一些开发时的成本，但是比起团队成员互相维护代码，以及可能的重构时带来的便利，这些成本是微不足道的，也很感谢组员的配合。</p><p>之前的开发中经常遇到本地开发完到最后不会部署的情况，所以这次在架构完一开始就配置好了 <a href="http://docker.com">Docker</a>，并且每天从 master 分支部署一次，这样对联合调试也帮助很大。</p><p>测试是软件工程中非常重要的一环，比较遗憾的是我们组由于开发周期非常紧以及测试相对来说困难，没能采用 <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> 的开发模式，不过在最后的一周我们补全了必要的测试，我们核心模块的测试覆盖率超过 95%。不过这次被坑的是性能测试，由于对 NoSQL 数据库的原理不够了解，一开始设计数据库的时候踩了坑，使用了不合适的组织方式，也因为没有提前性能测试，直到接近 ddl 的时候才发现性能很差，经过重重排查后发现是数据库的锅，连夜重构，索性前期架构模块划分合理，数据库操作被包在一个模块里，所以重构没有遇到很大的困难，吸取的教训是每添加一个功能都该进行一次性能测试，这样既能实时 profile，也能及时发现不合理的操作避免无谓的重构。</p><p>作为 API 小组，我们的文档非常重要，不过我们组都不是很擅长写文档，这里感谢马子俊同学承包了几乎所有的文档工作，写出了完整的接口文档供其他组的同学使用，并受到了好评。</p><p>不过担任 API 小组也让人体会到了甲方的坑爹之处，毕竟别的组的项目都是自己提需求，自己伪装成用户，可以什么好做做什么。起初我组只打算给一到两组提供 API，甚至没有的话完全可以自己搭建客户端来展示，后来在老师的要求下为其他所有组提供相关的 API，不得不说这并不是个愉快的体验，我组面临二十来个甲方提需求不堪重负，甚至相当一部分需求是受限于学校系统无法完成的，虽然让他们自己做他们也完不成，但是要求我们提供的时候丝毫没有觉悟。此外我们原来希望联合的小组开发进度不要太快，这样我们可以比较优雅地组织我们的代码，但部分强力的组加入后我们不得不赶工。出于尽可能让他们能够稳定开发的目的，我组不得不先以功能为第一目的，在安全性、性能等原本很重要的地方做一些让步以适应他们的开发。而且人多口杂需求多，在某些新加入的组的要求下被迫做出一些对已经稳定的 API 修改接口的行为，从某种程度上来说我们拉低了他们的开发进度，他们拉低了我们的代码质量。</p><p>这个项目从功能上来讲并不是我开发过的最复杂的应用，实现的功能也比较基本，但是从组织模式上来说是最工程化的，也在合作中收获了很多，感谢软工课给我的机会。最后，对课程的建议主要是前期文档实在有点多，很多实现细节不可能在开发前就确定，文档也随着每个迭代更新或许更合理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
